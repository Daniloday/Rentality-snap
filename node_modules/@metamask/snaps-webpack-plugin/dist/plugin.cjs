"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const snaps_sdk_1 = require("@metamask/snaps-sdk");
const node_1 = require("@metamask/snaps-utils/node");
const utils_1 = require("@metamask/utils");
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const webpack_1 = require("webpack");
const webpack_sources_1 = require("webpack-sources");
const PLUGIN_NAME = 'SnapsWebpackPlugin';
class SnapsWebpackPlugin {
    /**
     * Construct an instance of the plugin.
     *
     * @param options - The post-process options.
     * @param options.stripComments - Whether to strip comments. Defaults to
     * `true`.
     * @param options.eval - Whether to evaluate the bundle to test SES
     * compatibility. Defaults to `true`.
     * @param options.manifestPath - The path to the manifest file. If provided,
     * the manifest will be validated. Defaults to
     * `process.cwd() + '/snap.manifest.json'`.
     * @param options.writeManifest - Whether to fix the manifest.
     * Defaults to `true`.
     */
    constructor(options) {
        this.options = {
            eval: true,
            manifestPath: path_1.default.join(process.cwd(), 'snap.manifest.json'),
            writeManifest: true,
            ...options,
        };
    }
    /**
     * Apply the plugin to the Webpack compiler. Hooks into the `processAssets`
     * stage to process the bundle.
     *
     * @param compiler - The Webpack compiler.
     */
    apply(compiler) {
        const { devtool } = compiler.options;
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) => {
            compilation.hooks.processAssets.tap({
                name: PLUGIN_NAME,
                stage: webpack_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY,
                additionalAssets: true,
            }, (assets) => {
                Object.keys(assets)
                    .filter((assetName) => assetName.endsWith('.js'))
                    .forEach((assetName) => {
                    const asset = assets[assetName];
                    const source = asset.source();
                    const sourceMap = asset.map();
                    try {
                        const processed = (0, node_1.postProcessBundle)(source, {
                            ...this.options,
                            sourceMap: Boolean(devtool),
                            inputSourceMap: devtool
                                ? sourceMap
                                : undefined,
                        });
                        if (processed.warnings.length > 0) {
                            const webpackErrors = processed.warnings.map((warning) => new webpack_1.WebpackError(warning));
                            compilation.warnings.push(...webpackErrors);
                        }
                        const replacement = processed.sourceMap
                            ? new webpack_sources_1.SourceMapSource(processed.code, assetName, processed.sourceMap, source, sourceMap)
                            : new webpack_sources_1.RawSource(processed.code);
                        // For some reason the type of `RawSource` is not compatible with
                        // Webpack's own `Source`, but works fine when casting it to `any`.
                        compilation.updateAsset(assetName, replacement);
                    }
                    catch (error) {
                        compilation.errors.push(new webpack_1.WebpackError((0, snaps_sdk_1.getErrorMessage)(error)));
                    }
                });
            });
        });
        compiler.hooks.afterEmit.tapPromise(PLUGIN_NAME, async (compilation) => {
            const file = compilation
                .getAssets()
                .find((asset) => asset.name.endsWith('.js'));
            (0, utils_1.assert)(file);
            (0, utils_1.assert)(compilation.outputOptions.path);
            const outputPath = compilation.outputOptions.path;
            const filePath = path_1.default.join(outputPath, file.name);
            const bundleFile = await (0, util_1.promisify)(compiler.outputFileSystem.readFile.bind(compiler.outputFileSystem))(filePath);
            (0, utils_1.assert)(bundleFile);
            const bundleContent = bundleFile.toString();
            if (this.options.eval) {
                await (0, node_1.useTemporaryFile)('snaps-bundle.js', bundleContent, (path) => (0, node_1.evalBundle)(path));
            }
            if (this.options.manifestPath) {
                const { reports } = await (0, node_1.checkManifest)(path_1.default.dirname(this.options.manifestPath), {
                    updateAndWriteManifest: this.options.writeManifest,
                    sourceCode: bundleContent,
                    writeFileFn: (0, util_1.promisify)(compiler.outputFileSystem.writeFile.bind(compiler.outputFileSystem)),
                });
                const errors = reports
                    .filter((report) => report.severity === 'error' && !report.wasFixed)
                    .map((report) => report.message);
                const warnings = reports
                    .filter((report) => report.severity === 'warning' && !report.wasFixed)
                    .map((report) => report.message);
                const fixed = reports
                    .filter((report) => report.wasFixed)
                    .map((report) => report.message);
                if (errors.length > 0) {
                    compilation.errors.push(...errors.map((error) => new webpack_1.WebpackError(error)));
                }
                if (warnings.length > 0) {
                    compilation.warnings.push(...warnings.map((warning) => new webpack_1.WebpackError(warning)));
                }
                if (fixed.length > 0) {
                    compilation.warnings.push(...fixed.map((problem) => new webpack_1.WebpackError(`${problem} (fixed)`)));
                }
            }
        });
    }
}
exports.default = SnapsWebpackPlugin;
//# sourceMappingURL=plugin.cjs.map