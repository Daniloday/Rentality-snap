"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evalBundle = exports.SnapEvalError = void 0;
const utils_1 = require("@metamask/utils");
const child_process_1 = require("child_process");
const path_1 = require("path");
const fs_1 = require("./fs.cjs");
class SnapEvalError extends Error {
    constructor(message, output) {
        super(message);
        this.name = 'SnapEvalError';
        this.output = output;
    }
}
exports.SnapEvalError = SnapEvalError;
/**
 * Spawn a new process to run the provided bundle in.
 *
 * @param bundlePath - The path to the bundle to run.
 * @returns `null` if the worker ran successfully.
 * @throws If the worker failed to run successfully.
 */
async function evalBundle(bundlePath) {
    await (0, fs_1.validateFilePath)(bundlePath);
    return new Promise((resolve, reject) => {
        const worker = (0, child_process_1.fork)((0, path_1.join)(__dirname, 'eval-worker.cjs'), [bundlePath], {
            // To avoid printing the output of the worker to the console, we set
            // `stdio` to `pipe` and handle the output ourselves.
            stdio: 'pipe',
        });
        let stdout = '';
        let stderr = '';
        (0, utils_1.assert)(worker.stdout, '`stdout` should be defined.');
        (0, utils_1.assert)(worker.stderr, '`stderr` should be defined.');
        worker.stdout.on('data', (data) => {
            stdout += data.toString();
        });
        worker.stderr.on('data', (data) => {
            stderr += data.toString();
        });
        worker.on('exit', (exitCode) => {
            const output = {
                stdout,
                stderr,
            };
            if (exitCode === 0) {
                return resolve(output);
            }
            return reject(new SnapEvalError(`Process exited with non-zero exit code: ${exitCode}.`, output));
        });
    });
}
exports.evalBundle = evalBundle;
//# sourceMappingURL=eval.cjs.map