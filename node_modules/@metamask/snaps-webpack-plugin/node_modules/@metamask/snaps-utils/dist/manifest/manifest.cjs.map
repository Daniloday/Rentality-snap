{"version":3,"file":"manifest.cjs","sourceRoot":"","sources":["../../src/manifest/manifest.ts"],"names":[],"mappings":"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","sourcesContent":["import { getErrorMessage } from '@metamask/snaps-sdk';\nimport type { Json } from '@metamask/utils';\nimport { assert, isPlainObject } from '@metamask/utils';\nimport { promises as fs } from 'fs';\nimport pathUtils from 'path';\n\nimport { deepClone } from '../deep-clone';\nimport { readJsonFile } from '../fs';\nimport { parseJson } from '../json';\nimport type { SnapFiles, UnvalidatedSnapFiles } from '../types';\nimport { NpmSnapFileNames } from '../types';\nimport { readVirtualFile, VirtualFile } from '../virtual-file/node';\nimport type { SnapManifest } from './validation';\nimport type { ValidatorResults } from './validator';\nimport { hasFixes, runValidators } from './validator';\nimport type { ValidatorMeta, ValidatorReport } from './validator-types';\n\nconst MANIFEST_SORT_ORDER: Record<keyof SnapManifest, number> = {\n  $schema: 1,\n  version: 2,\n  description: 3,\n  proposedName: 4,\n  repository: 5,\n  source: 6,\n  initialConnections: 7,\n  initialPermissions: 8,\n  platformVersion: 9,\n  manifestVersion: 10,\n};\n\nexport type CheckManifestReport = Omit<ValidatorReport, 'fix'> & {\n  wasFixed?: boolean;\n};\n\n/**\n * The result from the `checkManifest` function.\n *\n * @property manifest - The fixed manifest object.\n * @property updated - Whether the manifest was written and updated.\n */\nexport type CheckManifestResult = {\n  files?: SnapFiles;\n  updated: boolean;\n  reports: CheckManifestReport[];\n};\n\nexport type WriteFileFunction = (path: string, data: string) => Promise<void>;\n\n/**\n * Validates a snap.manifest.json file. Attempts to fix the manifest and write\n * the fixed version to disk if `writeManifest` is true. Throws if validation\n * fails.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param options - Additional options for the function.\n * @param options.sourceCode - The source code of the Snap.\n * @param options.writeFileFn - The function to use to write the manifest to disk.\n * @param options.updateAndWriteManifest - Whether to auto-magically try to fix errors and then write the manifest to disk.\n * @returns Whether the manifest was updated, and an array of warnings that\n * were encountered during processing of the manifest files.\n */\nexport async function checkManifest(\n  basePath: string,\n  {\n    updateAndWriteManifest = true,\n    sourceCode,\n    writeFileFn = fs.writeFile,\n  }: {\n    updateAndWriteManifest?: boolean;\n    sourceCode?: string;\n    writeFileFn?: WriteFileFunction;\n  } = {},\n): Promise<CheckManifestResult> {\n  const manifestPath = pathUtils.join(basePath, NpmSnapFileNames.Manifest);\n  const manifestFile = await readJsonFile(manifestPath);\n  const unvalidatedManifest = manifestFile.result;\n\n  const packageFile = await readJsonFile(\n    pathUtils.join(basePath, NpmSnapFileNames.PackageJson),\n  );\n\n  const auxiliaryFilePaths = getSnapFilePaths(\n    unvalidatedManifest,\n    (manifest) => manifest?.source?.files,\n  );\n\n  const localizationFilePaths = getSnapFilePaths(\n    unvalidatedManifest,\n    (manifest) => manifest?.source?.locales,\n  );\n  const localizationFiles =\n    (await getSnapFiles(basePath, localizationFilePaths)) ?? [];\n  for (const localization of localizationFiles) {\n    try {\n      localization.result = parseJson(localization.toString());\n    } catch (error) {\n      assert(error instanceof SyntaxError, error);\n      throw new Error(\n        `Failed to parse localization file \"${localization.path}\" as JSON.`,\n      );\n    }\n  }\n\n  const snapFiles: UnvalidatedSnapFiles = {\n    manifest: manifestFile,\n    packageJson: packageFile,\n    sourceCode: await getSnapSourceCode(\n      basePath,\n      unvalidatedManifest,\n      sourceCode,\n    ),\n    svgIcon: await getSnapIcon(basePath, unvalidatedManifest),\n    // Intentionally pass null as the encoding here since the files may be binary\n    auxiliaryFiles:\n      (await getSnapFiles(basePath, auxiliaryFilePaths, null)) ?? [],\n    localizationFiles,\n  };\n\n  const validatorResults = await runValidators(snapFiles);\n  let manifestResults: CheckManifestResult = {\n    updated: false,\n    files: validatorResults.files,\n    reports: validatorResults.reports,\n  };\n\n  if (updateAndWriteManifest && hasFixes(manifestResults)) {\n    const fixedResults = await runFixes(validatorResults);\n\n    if (fixedResults.updated) {\n      manifestResults = fixedResults;\n\n      assert(manifestResults.files);\n\n      try {\n        await writeFileFn(\n          pathUtils.join(basePath, NpmSnapFileNames.Manifest),\n          manifestResults.files.manifest.toString(),\n        );\n      } catch (error) {\n        // Note: This error isn't pushed to the errors array, because it's not an\n        // error in the manifest itself.\n        throw new Error(\n          `Failed to update \"snap.manifest.json\": ${getErrorMessage(error)}`,\n        );\n      }\n    }\n  }\n\n  return manifestResults;\n}\n\n/**\n * Run the algorithm for automatically fixing errors in manifest.\n *\n * The algorithm updates the manifest by fixing all fixable problems,\n * and then run validation again to check if the new manifest is now correct.\n * If not correct, the algorithm will use the manifest from previous iteration\n * and try again `MAX_ATTEMPTS` times to update it before bailing and\n * resulting in failure.\n *\n * @param results - Results of the initial run of validation.\n * @param rules - Optional list of rules to run the fixes with.\n * @returns The updated manifest and whether it was updated.\n */\nexport async function runFixes(\n  results: ValidatorResults,\n  rules?: ValidatorMeta[],\n): Promise<CheckManifestResult> {\n  let shouldRunFixes = true;\n  const MAX_ATTEMPTS = 10;\n\n  assert(results.files);\n\n  let fixResults: ValidatorResults = results;\n  assert(fixResults.files);\n  fixResults.files.manifest = fixResults.files.manifest.clone();\n\n  for (\n    let attempts = 1;\n    shouldRunFixes && attempts <= MAX_ATTEMPTS;\n    attempts++\n  ) {\n    assert(fixResults.files);\n\n    let manifest = fixResults.files.manifest.result;\n\n    const fixable = fixResults.reports.filter((report) => report.fix);\n    for (const report of fixable) {\n      assert(report.fix);\n      ({ manifest } = await report.fix({ manifest }));\n    }\n\n    fixResults.files.manifest.value = `${JSON.stringify(\n      getWritableManifest(manifest),\n      null,\n      2,\n    )}\\n`;\n    fixResults.files.manifest.result = manifest;\n\n    fixResults = await runValidators(fixResults.files, rules);\n    shouldRunFixes = hasFixes(fixResults);\n  }\n\n  const initialReports: (CheckManifestReport & ValidatorReport)[] = deepClone(\n    results.reports,\n  );\n\n  // Was fixed\n  if (!shouldRunFixes) {\n    for (const report of initialReports) {\n      if (report.fix) {\n        report.wasFixed = true;\n        delete report.fix;\n      }\n    }\n\n    return {\n      files: fixResults.files,\n      updated: true,\n      reports: initialReports,\n    };\n  }\n\n  for (const report of initialReports) {\n    delete report.fix;\n  }\n\n  return {\n    files: results.files,\n    updated: false,\n    reports: initialReports,\n  };\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * bundle source file location and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @param sourceCode - Override source code for plugins.\n * @returns The contents of the bundle file, if any.\n */\nexport async function getSnapSourceCode(\n  basePath: string,\n  manifest: Json,\n  sourceCode?: string,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const sourceFilePath = (manifest as Partial<SnapManifest>).source?.location\n    ?.npm?.filePath;\n\n  if (!sourceFilePath) {\n    return undefined;\n  }\n\n  if (sourceCode) {\n    return new VirtualFile({\n      path: pathUtils.join(basePath, sourceFilePath),\n      value: sourceCode,\n    });\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, sourceFilePath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(\n      `Failed to read snap bundle file: ${getErrorMessage(error)}`,\n    );\n  }\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * icon and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @returns The contents of the icon, if any.\n */\nexport async function getSnapIcon(\n  basePath: string,\n  manifest: Json,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const iconPath = (manifest as Partial<SnapManifest>).source?.location?.npm\n    ?.iconPath;\n\n  if (!iconPath) {\n    return undefined;\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, iconPath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(`Failed to read snap icon file: ${getErrorMessage(error)}`);\n  }\n}\n\n/**\n * Get an array of paths from an unvalidated Snap manifest.\n *\n * @param manifest - The unvalidated Snap manifest file contents.\n * @param selector - A function that returns the paths to the files.\n * @returns The paths to the files, if any.\n */\nexport function getSnapFilePaths(\n  manifest: Json,\n  selector: (manifest: Partial<SnapManifest>) => string[] | undefined,\n) {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const snapManifest = manifest as Partial<SnapManifest>;\n  const paths = selector(snapManifest);\n\n  if (!Array.isArray(paths)) {\n    return undefined;\n  }\n\n  return paths;\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the files with the\n * given paths and read them.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param paths - The paths to the files.\n * @param encoding - An optional encoding to pass down to readVirtualFile.\n * @returns A list of auxiliary files and their contents, if any.\n */\nexport async function getSnapFiles(\n  basePath: string,\n  paths: string[] | undefined,\n  encoding: BufferEncoding | null = 'utf8',\n): Promise<VirtualFile[] | undefined> {\n  if (!paths) {\n    return undefined;\n  }\n\n  try {\n    return await Promise.all(\n      paths.map(async (filePath) =>\n        readVirtualFile(pathUtils.join(basePath, filePath), encoding),\n      ),\n    );\n  } catch (error) {\n    throw new Error(`Failed to read snap files: ${getErrorMessage(error)}`);\n  }\n}\n\n/**\n * Sorts the given manifest in our preferred sort order and removes the\n * `repository` field if it is falsy (it may be `null`).\n *\n * @param manifest - The manifest to sort and modify.\n * @returns The disk-ready manifest.\n */\nexport function getWritableManifest(manifest: SnapManifest): SnapManifest {\n  const { repository, ...remaining } = manifest;\n\n  const keys = Object.keys(\n    repository ? { ...remaining, repository } : remaining,\n  ) as (keyof SnapManifest)[];\n\n  const writableManifest = keys\n    .sort((a, b) => MANIFEST_SORT_ORDER[a] - MANIFEST_SORT_ORDER[b])\n    .reduce<Partial<SnapManifest>>(\n      (result, key) => ({\n        ...result,\n        [key]: manifest[key],\n      }),\n      {},\n    );\n\n  return writableManifest as SnapManifest;\n}\n"]}