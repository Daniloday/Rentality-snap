var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Context_nextSeverity;
import { assert } from "@metamask/utils";
import * as defaultValidators from "./validators/index.mjs";
class Context {
    constructor() {
        this.reports = [];
        _Context_nextSeverity.set(this, undefined);
    }
    report(message, fix) {
        assert(__classPrivateFieldGet(this, _Context_nextSeverity, "f") !== undefined);
        this.reports.push({
            severity: __classPrivateFieldGet(this, _Context_nextSeverity, "f"),
            message,
            fix,
        });
    }
    prepareForValidator(settings) {
        __classPrivateFieldSet(this, _Context_nextSeverity, settings.severity, "f");
    }
    get hasErrors() {
        return this.reports.some((report) => report.severity === 'error');
    }
}
_Context_nextSeverity = new WeakMap();
/**
 * Verify that snap files are completely valid.
 * First it runs validators on unparsed files to check structure.
 * Secondly it runs validators on parsed files to check semantics.
 *
 * @param files - All files required to run a snap.
 * @param rules - Validators to run.
 * @returns The validation results.
 */
// TODO(ritave): snap.manifest.json and package.json should check
//               json parsing as well instead of assuming it's
//               already parsed
export async function runValidators(files, rules = Object.values(defaultValidators)) {
    const context = new Context();
    for (const rule of rules) {
        context.prepareForValidator({
            severity: rule.severity,
        });
        await rule.structureCheck?.(files, context);
    }
    if (context.hasErrors) {
        return {
            reports: context.reports,
        };
    }
    for (const rule of rules) {
        context.prepareForValidator({
            severity: rule.severity,
        });
        await rule.semanticCheck?.(files, context);
    }
    return {
        files: files,
        reports: context.reports,
    };
}
/**
 * Get whether any reports has pending fixes.
 *
 * @param results - Results of the validation run.
 * @returns Whether there are fixes pending.
 */
export function hasFixes(results) {
    return results.reports.some((report) => report.fix);
}
//# sourceMappingURL=validator.mjs.map