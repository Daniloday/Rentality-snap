/// <reference types="node" />
import type { Json } from "@metamask/utils";
import type { SnapFiles } from "../types.mjs";
import { VirtualFile } from "../virtual-file/node.mjs";
import type { SnapManifest } from "./validation.mjs";
import type { ValidatorResults } from "./validator.mjs";
import type { ValidatorMeta, ValidatorReport } from "./validator-types.mjs";
export type CheckManifestReport = Omit<ValidatorReport, 'fix'> & {
    wasFixed?: boolean;
};
/**
 * The result from the `checkManifest` function.
 *
 * @property manifest - The fixed manifest object.
 * @property updated - Whether the manifest was written and updated.
 */
export type CheckManifestResult = {
    files?: SnapFiles;
    updated: boolean;
    reports: CheckManifestReport[];
};
export type WriteFileFunction = (path: string, data: string) => Promise<void>;
/**
 * Validates a snap.manifest.json file. Attempts to fix the manifest and write
 * the fixed version to disk if `writeManifest` is true. Throws if validation
 * fails.
 *
 * @param basePath - The path to the folder with the manifest files.
 * @param options - Additional options for the function.
 * @param options.sourceCode - The source code of the Snap.
 * @param options.writeFileFn - The function to use to write the manifest to disk.
 * @param options.updateAndWriteManifest - Whether to auto-magically try to fix errors and then write the manifest to disk.
 * @returns Whether the manifest was updated, and an array of warnings that
 * were encountered during processing of the manifest files.
 */
export declare function checkManifest(basePath: string, { updateAndWriteManifest, sourceCode, writeFileFn, }?: {
    updateAndWriteManifest?: boolean;
    sourceCode?: string;
    writeFileFn?: WriteFileFunction;
}): Promise<CheckManifestResult>;
/**
 * Run the algorithm for automatically fixing errors in manifest.
 *
 * The algorithm updates the manifest by fixing all fixable problems,
 * and then run validation again to check if the new manifest is now correct.
 * If not correct, the algorithm will use the manifest from previous iteration
 * and try again `MAX_ATTEMPTS` times to update it before bailing and
 * resulting in failure.
 *
 * @param results - Results of the initial run of validation.
 * @param rules - Optional list of rules to run the fixes with.
 * @returns The updated manifest and whether it was updated.
 */
export declare function runFixes(results: ValidatorResults, rules?: ValidatorMeta[]): Promise<CheckManifestResult>;
/**
 * Given an unvalidated Snap manifest, attempts to extract the location of the
 * bundle source file location and read the file.
 *
 * @param basePath - The path to the folder with the manifest files.
 * @param manifest - The unvalidated Snap manifest file contents.
 * @param sourceCode - Override source code for plugins.
 * @returns The contents of the bundle file, if any.
 */
export declare function getSnapSourceCode(basePath: string, manifest: Json, sourceCode?: string): Promise<VirtualFile | undefined>;
/**
 * Given an unvalidated Snap manifest, attempts to extract the location of the
 * icon and read the file.
 *
 * @param basePath - The path to the folder with the manifest files.
 * @param manifest - The unvalidated Snap manifest file contents.
 * @returns The contents of the icon, if any.
 */
export declare function getSnapIcon(basePath: string, manifest: Json): Promise<VirtualFile | undefined>;
/**
 * Get an array of paths from an unvalidated Snap manifest.
 *
 * @param manifest - The unvalidated Snap manifest file contents.
 * @param selector - A function that returns the paths to the files.
 * @returns The paths to the files, if any.
 */
export declare function getSnapFilePaths(manifest: Json, selector: (manifest: Partial<SnapManifest>) => string[] | undefined): string[] | undefined;
/**
 * Given an unvalidated Snap manifest, attempts to extract the files with the
 * given paths and read them.
 *
 * @param basePath - The path to the folder with the manifest files.
 * @param paths - The paths to the files.
 * @param encoding - An optional encoding to pass down to readVirtualFile.
 * @returns A list of auxiliary files and their contents, if any.
 */
export declare function getSnapFiles(basePath: string, paths: string[] | undefined, encoding?: BufferEncoding | null): Promise<VirtualFile[] | undefined>;
/**
 * Sorts the given manifest in our preferred sort order and removes the
 * `repository` field if it is falsy (it may be `null`).
 *
 * @param manifest - The manifest to sort and modify.
 * @returns The disk-ready manifest.
 */
export declare function getWritableManifest(manifest: SnapManifest): SnapManifest;
//# sourceMappingURL=manifest.d.mts.map