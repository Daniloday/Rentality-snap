{"version":3,"file":"eval.cjs","sourceRoot":"","sources":["../src/eval.ts"],"names":[],"mappings":";;;AAAA,2CAAyC;AACzC,iDAAqC;AACrC,+BAA4B;AAE5B,iCAAwC;AAOxC,MAAa,aAAc,SAAQ,KAAK;IAGtC,YAAY,OAAe,EAAE,MAAkB;QAC7C,KAAK,CAAC,OAAO,CAAC,CAAC;QAEf,IAAI,CAAC,IAAI,GAAG,eAAe,CAAC;QAC5B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;CACF;AATD,sCASC;AAED;;;;;;GAMG;AACI,KAAK,UAAU,UAAU,CAAC,UAAkB;IACjD,MAAM,IAAA,qBAAgB,EAAC,UAAU,CAAC,CAAC;IAEnC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACrC,MAAM,MAAM,GAAG,IAAA,oBAAI,EAAC,IAAA,WAAI,EAAC,SAAS,EAAE,iBAAiB,CAAC,EAAE,CAAC,UAAU,CAAC,EAAE;YACpE,oEAAoE;YACpE,qDAAqD;YACrD,KAAK,EAAE,MAAM;SACd,CAAC,CAAC;QAEH,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,IAAI,MAAM,GAAG,EAAE,CAAC;QAEhB,IAAA,cAAM,EAAC,MAAM,CAAC,MAAM,EAAE,6BAA6B,CAAC,CAAC;QACrD,IAAA,cAAM,EAAC,MAAM,CAAC,MAAM,EAAE,6BAA6B,CAAC,CAAC;QAErD,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAY,EAAE,EAAE;YACxC,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;QAC5B,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAY,EAAE,EAAE;YACxC,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;QAC5B,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,QAAgB,EAAE,EAAE;YACrC,MAAM,MAAM,GAAG;gBACb,MAAM;gBACN,MAAM;aACP,CAAC;YAEF,IAAI,QAAQ,KAAK,CAAC,EAAE,CAAC;gBACnB,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC;YACzB,CAAC;YAED,OAAO,MAAM,CACX,IAAI,aAAa,CACf,2CAA2C,QAAQ,GAAG,EACtD,MAAM,CACP,CACF,CAAC;QACJ,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AA1CD,gCA0CC","sourcesContent":["import { assert } from '@metamask/utils';\nimport { fork } from 'child_process';\nimport { join } from 'path';\n\nimport { validateFilePath } from './fs';\n\nexport type EvalOutput = {\n  stdout: string;\n  stderr: string;\n};\n\nexport class SnapEvalError extends Error {\n  readonly output: EvalOutput;\n\n  constructor(message: string, output: EvalOutput) {\n    super(message);\n\n    this.name = 'SnapEvalError';\n    this.output = output;\n  }\n}\n\n/**\n * Spawn a new process to run the provided bundle in.\n *\n * @param bundlePath - The path to the bundle to run.\n * @returns `null` if the worker ran successfully.\n * @throws If the worker failed to run successfully.\n */\nexport async function evalBundle(bundlePath: string): Promise<EvalOutput> {\n  await validateFilePath(bundlePath);\n\n  return new Promise((resolve, reject) => {\n    const worker = fork(join(__dirname, 'eval-worker.cjs'), [bundlePath], {\n      // To avoid printing the output of the worker to the console, we set\n      // `stdio` to `pipe` and handle the output ourselves.\n      stdio: 'pipe',\n    });\n\n    let stdout = '';\n    let stderr = '';\n\n    assert(worker.stdout, '`stdout` should be defined.');\n    assert(worker.stderr, '`stderr` should be defined.');\n\n    worker.stdout.on('data', (data: Buffer) => {\n      stdout += data.toString();\n    });\n\n    worker.stderr.on('data', (data: Buffer) => {\n      stderr += data.toString();\n    });\n\n    worker.on('exit', (exitCode: number) => {\n      const output = {\n        stdout,\n        stderr,\n      };\n\n      if (exitCode === 0) {\n        return resolve(output);\n      }\n\n      return reject(\n        new SnapEvalError(\n          `Process exited with non-zero exit code: ${exitCode}.`,\n          output,\n        ),\n      );\n    });\n  });\n}\n"]}