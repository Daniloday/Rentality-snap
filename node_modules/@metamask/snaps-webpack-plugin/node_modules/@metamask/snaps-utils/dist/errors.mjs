var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _WrappedSnapError_error, _WrappedSnapError_message, _WrappedSnapError_stack;
import { errorCodes, JsonRpcError as RpcError, serializeCause } from "@metamask/rpc-errors";
import { getErrorMessage, getErrorStack, SNAP_ERROR_CODE, SNAP_ERROR_MESSAGE } from "@metamask/snaps-sdk";
import { isObject, isJsonRpcError } from "@metamask/utils";
export const SNAP_ERROR_WRAPPER_CODE = -31001;
export const SNAP_ERROR_WRAPPER_MESSAGE = 'Wrapped Snap Error';
export class WrappedSnapError extends Error {
    /**
     * Create a new `WrappedSnapError`.
     *
     * @param error - The error to create the `WrappedSnapError` from.
     */
    constructor(error) {
        const message = getErrorMessage(error);
        super(message);
        _WrappedSnapError_error.set(this, void 0);
        _WrappedSnapError_message.set(this, void 0);
        _WrappedSnapError_stack.set(this, void 0);
        __classPrivateFieldSet(this, _WrappedSnapError_error, error, "f");
        __classPrivateFieldSet(this, _WrappedSnapError_message, message, "f");
        __classPrivateFieldSet(this, _WrappedSnapError_stack, getErrorStack(error), "f");
    }
    /**
     * The error name.
     *
     * @returns The error name.
     */
    get name() {
        return 'WrappedSnapError';
    }
    /**
     * The error message.
     *
     * @returns The error message.
     */
    get message() {
        return __classPrivateFieldGet(this, _WrappedSnapError_message, "f");
    }
    /**
     * The error stack.
     *
     * @returns The error stack.
     */
    get stack() {
        return __classPrivateFieldGet(this, _WrappedSnapError_stack, "f");
    }
    /**
     * Convert the error to a JSON object.
     *
     * @returns The JSON object.
     */
    toJSON() {
        const cause = isSnapError(__classPrivateFieldGet(this, _WrappedSnapError_error, "f"))
            ? __classPrivateFieldGet(this, _WrappedSnapError_error, "f").serialize()
            : serializeCause(__classPrivateFieldGet(this, _WrappedSnapError_error, "f"));
        return {
            code: SNAP_ERROR_WRAPPER_CODE,
            message: SNAP_ERROR_WRAPPER_MESSAGE,
            data: {
                cause,
            },
        };
    }
    /**
     * Serialize the error to a JSON object. This is called by
     * `@metamask/rpc-errors` when serializing the error.
     *
     * @returns The JSON object.
     */
    serialize() {
        return this.toJSON();
    }
}
_WrappedSnapError_error = new WeakMap(), _WrappedSnapError_message = new WeakMap(), _WrappedSnapError_stack = new WeakMap();
/**
 * Check if an object is a `SnapError`.
 *
 * @param error - The object to check.
 * @returns Whether the object is a `SnapError`.
 */
export function isSnapError(error) {
    if (isObject(error) &&
        'serialize' in error &&
        typeof error.serialize === 'function') {
        const serialized = error.serialize();
        return isJsonRpcError(serialized) && isSerializedSnapError(serialized);
    }
    return false;
}
/**
 * Check if a JSON-RPC error is a `SnapError`.
 *
 * @param error - The object to check.
 * @returns Whether the object is a `SnapError`.
 */
export function isSerializedSnapError(error) {
    return error.code === SNAP_ERROR_CODE && error.message === SNAP_ERROR_MESSAGE;
}
/**
 * Check if a JSON-RPC error is a `WrappedSnapError`.
 *
 * @param error - The object to check.
 * @returns Whether the object is a `WrappedSnapError`.
 */
export function isWrappedSnapError(error) {
    return (isJsonRpcError(error) &&
        error.code === SNAP_ERROR_WRAPPER_CODE &&
        error.message === SNAP_ERROR_WRAPPER_MESSAGE);
}
/**
 * Get a JSON-RPC error with the given code, message, stack, and data.
 *
 * @param code - The error code.
 * @param message - The error message.
 * @param stack - The error stack.
 * @param data - Additional data for the error.
 * @returns The JSON-RPC error.
 */
function getJsonRpcError(code, message, stack, data) {
    const error = new RpcError(code, message, data);
    error.stack = stack;
    return error;
}
/**
 * Attempt to unwrap an unknown error to a `JsonRpcError`. This function will
 * try to get the error code, message, and data from the error, and return a
 * `JsonRpcError` with those properties.
 *
 * @param error - The error to unwrap.
 * @returns A tuple containing the unwrapped error and a boolean indicating
 * whether the error was handled.
 */
export function unwrapError(error) {
    // This logic is a bit complicated, but it's necessary to handle all the
    // different types of errors that can be thrown by a Snap.
    // If the error is a wrapped Snap error, unwrap it.
    if (isWrappedSnapError(error)) {
        // The wrapped error can be a JSON-RPC error, or an unknown error. If it's
        // a JSON-RPC error, we can unwrap it further.
        if (isJsonRpcError(error.data.cause)) {
            // If the JSON-RPC error is a wrapped Snap error, unwrap it further.
            if (isSerializedSnapError(error.data.cause)) {
                const { code, message, stack, data } = error.data.cause.data.cause;
                return [getJsonRpcError(code, message, stack, data), true];
            }
            // Otherwise, we use the original JSON-RPC error.
            const { code, message, stack, data } = error.data.cause;
            return [getJsonRpcError(code, message, stack, data), false];
        }
        // Otherwise, we throw an internal error with the wrapped error as the
        // message.
        return [
            getJsonRpcError(errorCodes.rpc.internal, getErrorMessage(error.data.cause), getErrorStack(error.data.cause)),
            false,
        ];
    }
    // The error can be a non-wrapped JSON-RPC error, in which case we can just
    // re-throw it with the same code, message, and data.
    if (isJsonRpcError(error)) {
        const { code, message, stack, data } = error;
        return [getJsonRpcError(code, message, stack, data), false];
    }
    // If the error is not a wrapped error, we don't know how to handle it, so we
    // throw an internal error with the error as the message.
    return [
        getJsonRpcError(errorCodes.rpc.internal, getErrorMessage(error), getErrorStack(error)),
        false,
    ];
}
//# sourceMappingURL=errors.mjs.map