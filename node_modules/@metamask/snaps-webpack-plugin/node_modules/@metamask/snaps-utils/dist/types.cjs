"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WALLET_SNAP_PERMISSION_KEY = exports.isValidUrl = exports.uri = exports.SNAP_STREAM_NAMES = exports.SnapIdPrefixes = exports.NpmSnapPackageJsonStruct = exports.NameStruct = exports.NpmSnapFileNames = void 0;
const superstruct_1 = require("@metamask/superstruct");
const utils_1 = require("@metamask/utils");
var NpmSnapFileNames;
(function (NpmSnapFileNames) {
    NpmSnapFileNames["PackageJson"] = "package.json";
    NpmSnapFileNames["Manifest"] = "snap.manifest.json";
})(NpmSnapFileNames || (exports.NpmSnapFileNames = NpmSnapFileNames = {}));
exports.NameStruct = (0, superstruct_1.size)((0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:@[a-z0-9-*~][a-z0-9-*._~]*\/)?[a-z0-9-~][a-z0-9-._~]*$/u), 1, 214);
// Note we use `type` instead of `object` here, because the latter does not
// allow unknown keys.
exports.NpmSnapPackageJsonStruct = (0, superstruct_1.type)({
    version: utils_1.VersionStruct,
    name: exports.NameStruct,
    main: (0, superstruct_1.optional)((0, superstruct_1.size)((0, superstruct_1.string)(), 1, Infinity)),
    repository: (0, superstruct_1.optional)((0, superstruct_1.type)({
        type: (0, superstruct_1.size)((0, superstruct_1.string)(), 1, Infinity),
        url: (0, superstruct_1.size)((0, superstruct_1.string)(), 1, Infinity),
    })),
});
/**
 * The possible prefixes for snap ids.
 */
/* eslint-disable @typescript-eslint/naming-convention */
var SnapIdPrefixes;
(function (SnapIdPrefixes) {
    SnapIdPrefixes["npm"] = "npm:";
    SnapIdPrefixes["local"] = "local:";
})(SnapIdPrefixes || (exports.SnapIdPrefixes = SnapIdPrefixes = {}));
/* eslint-enable @typescript-eslint/naming-convention */
/* eslint-disable @typescript-eslint/naming-convention */
var SNAP_STREAM_NAMES;
(function (SNAP_STREAM_NAMES) {
    SNAP_STREAM_NAMES["JSON_RPC"] = "jsonRpc";
    SNAP_STREAM_NAMES["COMMAND"] = "command";
})(SNAP_STREAM_NAMES || (exports.SNAP_STREAM_NAMES = SNAP_STREAM_NAMES = {}));
const uri = (opts = {}) => (0, superstruct_1.refine)((0, superstruct_1.union)([(0, superstruct_1.string)(), (0, superstruct_1.instance)(URL)]), 'uri', (value) => {
    try {
        const url = new URL(value);
        const UrlStruct = (0, superstruct_1.type)(opts);
        (0, superstruct_1.assert)(url, UrlStruct);
        return true;
    }
    catch {
        return `Expected URL, got "${value.toString()}".`;
    }
});
exports.uri = uri;
/**
 * Returns whether a given value is a valid URL.
 *
 * @param url - The value to check.
 * @param opts - Optional constraints for url checking.
 * @returns Whether `url` is valid URL or not.
 */
function isValidUrl(url, opts = {}) {
    return (0, superstruct_1.is)(url, (0, exports.uri)(opts));
}
exports.isValidUrl = isValidUrl;
// redefining here to avoid circular dependency
exports.WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';
//# sourceMappingURL=types.cjs.map