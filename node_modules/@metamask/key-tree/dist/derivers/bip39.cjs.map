{"version":3,"file":"bip39.cjs","sourceRoot":"","sources":["../../src/derivers/bip39.ts"],"names":[],"mappings":"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","sourcesContent":["import { mnemonicToEntropy } from '@metamask/scure-bip39';\nimport { wordlist as englishWordlist } from '@metamask/scure-bip39/dist/wordlists/english';\nimport { assert, stringToBytes } from '@metamask/utils';\n\nimport type { DeriveChildKeyArgs } from '.';\nimport type { BIP39StringNode, Network } from '../constants';\nimport { BYTES_KEY_LENGTH } from '../constants';\nimport type { CryptographicFunctions } from '../cryptography';\nimport { hmacSha512, pbkdf2Sha512 } from '../cryptography';\nimport type { Curve } from '../curves';\nimport { SLIP10Node } from '../SLIP10Node';\nimport { getFingerprint } from '../utils';\n\nconst MNEMONIC_PHRASE_LENGTHS = [12, 15, 18, 21, 24];\n\n/**\n * Validate a BIP-39 mnemonic phrase. The phrase must:\n *\n * - Consist of 12, 15, 18, 21, or 24 words.\n * - Contain only words from the English wordlist.\n *\n * @param mnemonicPhrase - The mnemonic phrase to validate.\n * @throws If the mnemonic phrase is invalid.\n */\nfunction validateMnemonicPhrase(mnemonicPhrase: string): void {\n  const words = mnemonicPhrase.split(' ');\n\n  assert(\n    MNEMONIC_PHRASE_LENGTHS.includes(words.length),\n    `Invalid mnemonic phrase: The mnemonic phrase must consist of 12, 15, 18, 21, or 24 words.`,\n  );\n\n  assert(\n    words.every((word) => englishWordlist.includes(word)),\n    'Invalid mnemonic phrase: The mnemonic phrase contains an unknown word.',\n  );\n}\n\n/**\n * Encode a BIP-39 mnemonic phrase to a `Uint8Array` for use in seed generation.\n * If the mnemonic is already a `Uint8Array`, it is assumed to contain the\n * indices of the words in the wordlist.\n *\n * @param mnemonic - The mnemonic phrase to encode.\n * @param wordlist - The wordlist to use.\n * @returns The encoded mnemonic phrase.\n */\nfunction encodeMnemonicPhrase(\n  mnemonic: string | Uint8Array,\n  wordlist: string[],\n): Uint8Array {\n  if (typeof mnemonic === 'string') {\n    validateMnemonicPhrase(mnemonic);\n    return stringToBytes(mnemonic.normalize('NFKD'));\n  }\n\n  const mnemonicString = Array.from(new Uint16Array(mnemonic.buffer))\n    .map((i) => wordlist[i])\n    .join(' ');\n\n  validateMnemonicPhrase(mnemonicString);\n  return stringToBytes(mnemonicString);\n}\n\n/**\n * Convert a BIP-39 mnemonic phrase to a seed.\n *\n * @param mnemonic - The BIP-39 mnemonic phrase to convert. If the mnemonic is a\n * `Uint8Array`, it is assumed to contain the indices of the words in the\n * English wordlist.\n * @param passphrase - The passphrase to use.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The seed.\n */\nexport async function mnemonicToSeed(\n  mnemonic: string | Uint8Array,\n  passphrase = '',\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<Uint8Array> {\n  const salt = `mnemonic${passphrase}`.normalize('NFKD');\n  return await pbkdf2Sha512(\n    encodeMnemonicPhrase(mnemonic, englishWordlist),\n    stringToBytes(salt),\n    2048,\n    64,\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Convert a BIP-39 mnemonic phrase to a multi path.\n *\n * @param mnemonic - The BIP-39 mnemonic phrase to convert.\n * @returns The multi path.\n */\nexport function bip39MnemonicToMultipath(mnemonic: string): BIP39StringNode {\n  return `bip39:${mnemonic.toLowerCase().trim()}`;\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 mnemonic phrase.\n *\n * @param options - The options for creating the node.\n * @param options.path - The multi path.\n * @param options.curve - The curve to use for derivation.\n * @param options.network - The network for the node. This is only used for\n * extended keys, and defaults to `mainnet`.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The node.\n */\nexport async function deriveChildKey(\n  { path, curve, network }: DeriveChildKeyArgs,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  switch (curve.masterNodeGenerationSpec) {\n    case 'slip10':\n      return createBip39KeyFromSeed(\n        await mnemonicToSeed(path, '', cryptographicFunctions),\n        curve,\n        network,\n        cryptographicFunctions,\n      );\n    case 'cip3':\n      return entropyToCip3MasterNode(\n        mnemonicToEntropy(path, englishWordlist),\n        curve,\n        network,\n        cryptographicFunctions,\n      );\n    default:\n      throw new Error('Unsupported master node generation spec.');\n  }\n}\n\n/**\n * Create a {@link SLIP10Node} from a BIP-39 seed.\n *\n * @param seed - The cryptographic seed bytes.\n * @param curve - The curve to use.\n * @param network - The network for the node. This is only used for extended\n * keys, and defaults to `mainnet`.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns An object containing the corresponding BIP-39 master key and chain\n * code.\n */\nexport async function createBip39KeyFromSeed(\n  seed: Uint8Array,\n  curve: Extract<Curve, { masterNodeGenerationSpec: 'slip10' }>,\n  network?: Network | undefined,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  assert(\n    seed.length >= 16 && seed.length <= 64,\n    'Invalid seed: The seed must be between 16 and 64 bytes long.',\n  );\n\n  const key = await hmacSha512(curve.secret, seed, cryptographicFunctions);\n  const privateKey = key.slice(0, BYTES_KEY_LENGTH);\n  const chainCode = key.slice(BYTES_KEY_LENGTH);\n\n  assert(\n    curve.isValidPrivateKey(privateKey),\n    'Invalid private key: The private key must greater than 0 and less than the curve order.',\n  );\n\n  const masterFingerprint = getFingerprint(\n    await curve.getPublicKey(privateKey, true),\n    curve.compressedPublicKeyLength,\n  );\n\n  return SLIP10Node.fromExtendedKey(\n    {\n      privateKey,\n      chainCode,\n      masterFingerprint,\n      network,\n      depth: 0,\n      parentFingerprint: 0,\n      index: 0,\n      curve: curve.name,\n    },\n    cryptographicFunctions,\n  );\n}\n\n/**\n * Create a {@link SLIP10Node} from BIP-39 entropy.\n * This function is consistent with the Icarus derivation scheme.\n * Icarus root key derivation scheme: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md.\n * CIP3: https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/CIP-0003.md#master-key-generation.\n *\n * @param entropy - The entropy value.\n * @param curve - The curve to use.\n * @param network - The network for the node. This is only used for extended\n * keys, and defaults to `mainnet`.\n * @param cryptographicFunctions - The cryptographic functions to use. If\n * provided, these will be used instead of the built-in implementations.\n * @returns The root key pair consisting of 64-byte private key and 32-byte chain code.\n */\nexport async function entropyToCip3MasterNode(\n  entropy: Uint8Array,\n  curve: Extract<Curve, { masterNodeGenerationSpec: 'cip3' }>,\n  network?: Network | undefined,\n  cryptographicFunctions?: CryptographicFunctions,\n): Promise<SLIP10Node> {\n  assert(\n    entropy.length >= 16 && entropy.length <= 64,\n    'Invalid entropy: The entropy must be between 16 and 64 bytes long.',\n  );\n\n  const rootNode = await pbkdf2Sha512(\n    curve.secret,\n    entropy,\n    4096,\n    96,\n    cryptographicFunctions,\n  );\n\n  // Consistent with the Icarus derivation scheme.\n  // https://github.com/cardano-foundation/CIPs/blob/09d7d8ee1bd64f7e6b20b5a6cae088039dce00cb/CIP-0003/Icarus.md\n  /* eslint-disable no-bitwise */\n  rootNode[0] &= 0b1111_1000;\n  rootNode[31] &= 0b0001_1111;\n  rootNode[31] |= 0b0100_0000;\n  /* eslint-enable no-bitwise */\n\n  const privateKey = rootNode.slice(0, curve.privateKeyLength);\n  const chainCode = rootNode.slice(curve.privateKeyLength);\n\n  assert(curve.isValidPrivateKey(privateKey), 'Invalid private key.');\n\n  const masterFingerprint = getFingerprint(\n    await curve.getPublicKey(privateKey),\n    curve.compressedPublicKeyLength,\n  );\n\n  return SLIP10Node.fromExtendedKey(\n    {\n      privateKey,\n      chainCode,\n      masterFingerprint,\n      network,\n      depth: 0,\n      parentFingerprint: 0,\n      index: 0,\n      curve: curve.name,\n    },\n    cryptographicFunctions,\n  );\n}\n"]}