"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWebpackConfig = exports.mergeLegacyOptions = exports.getConfigByArgv = exports.resolveConfig = exports.loadConfig = exports.getConfig = exports.LegacyOptionsStruct = exports.SnapsConfigStruct = exports.SnapsWebpackConfigStruct = exports.SnapsBrowserifyConfigStruct = void 0;
const snaps_sdk_1 = require("@metamask/snaps-sdk");
const node_1 = require("@metamask/snaps-utils/node");
const superstruct_1 = require("@metamask/superstruct");
const utils_1 = require("@metamask/utils");
const core_1 = require("@swc/core");
const chalk_1 = require("chalk");
const promises_1 = require("fs/promises");
const module_1 = __importDefault(require("module"));
const path_1 = require("path");
const builders_1 = require("./builders.cjs");
const errors_1 = require("./errors.cjs");
const structs_1 = require("./structs.cjs");
const utils_2 = require("./utils/index.cjs");
const CONFIG_FILES = [utils_2.CONFIG_FILE, utils_2.TS_CONFIG_FILE];
// This struct is essentially the same as the `func` struct, but it's defined
// separately so that we include the function type in the inferred TypeScript
// type definitions.
const SnapsBrowserifyBundlerCustomizerFunctionStruct = (0, superstruct_1.define)('function', (0, superstruct_1.func)().validator);
exports.SnapsBrowserifyConfigStruct = (0, superstruct_1.object)({
    bundler: (0, snaps_sdk_1.literal)('browserify'),
    cliOptions: (0, superstruct_1.defaulted)((0, superstruct_1.object)({
        bundle: (0, superstruct_1.optional)((0, structs_1.file)()),
        dist: (0, superstruct_1.defaulted)((0, structs_1.file)(), 'dist'),
        eval: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), true),
        manifest: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), true),
        port: (0, superstruct_1.defaulted)((0, superstruct_1.number)(), 8081),
        outfileName: (0, superstruct_1.defaulted)((0, superstruct_1.string)(), 'bundle.js'),
        root: (0, superstruct_1.defaulted)((0, structs_1.file)(), process.cwd()),
        sourceMaps: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
        src: (0, superstruct_1.defaulted)((0, structs_1.file)(), 'src/index.js'),
        stripComments: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), true),
        suppressWarnings: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
        transpilationMode: (0, superstruct_1.defaulted)((0, snaps_sdk_1.union)([(0, snaps_sdk_1.literal)('localAndDeps'), (0, snaps_sdk_1.literal)('localOnly'), (0, snaps_sdk_1.literal)('none')]), 'localOnly'),
        depsToTranspile: (0, superstruct_1.defaulted)((0, superstruct_1.array)((0, superstruct_1.string)()), []),
        verboseErrors: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), true),
        writeManifest: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), true),
        serve: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), true),
    }), {}),
    bundlerCustomizer: (0, superstruct_1.optional)(SnapsBrowserifyBundlerCustomizerFunctionStruct),
});
// This struct is essentially the same as the `func` struct, but it's defined
// separately so that we include the function type in the inferred TypeScript
// type definitions.
const SnapsWebpackCustomizeWebpackConfigFunctionStruct = (0, superstruct_1.define)('function', (0, superstruct_1.func)().validator);
exports.SnapsWebpackConfigStruct = (0, superstruct_1.object)({
    bundler: (0, superstruct_1.defaulted)((0, snaps_sdk_1.literal)('webpack'), 'webpack'),
    input: (0, superstruct_1.defaulted)((0, structs_1.file)(), (0, path_1.resolve)(process.cwd(), 'src/index.js')),
    sourceMap: (0, superstruct_1.defaulted)((0, snaps_sdk_1.union)([(0, superstruct_1.boolean)(), (0, snaps_sdk_1.literal)('inline')]), false),
    evaluate: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), true),
    output: (0, superstruct_1.defaulted)((0, superstruct_1.object)({
        path: (0, superstruct_1.defaulted)((0, structs_1.file)(), (0, path_1.resolve)(process.cwd(), 'dist')),
        filename: (0, superstruct_1.defaulted)((0, superstruct_1.string)(), 'bundle.js'),
        clean: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
        minimize: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), true),
    }), {}),
    manifest: (0, superstruct_1.defaulted)((0, superstruct_1.object)({
        path: (0, superstruct_1.defaulted)((0, structs_1.file)(), (0, path_1.resolve)(process.cwd(), 'snap.manifest.json')),
        update: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), true),
    }), {}),
    server: (0, superstruct_1.defaulted)((0, superstruct_1.object)({
        enabled: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), true),
        root: (0, superstruct_1.defaulted)((0, structs_1.file)(), process.cwd()),
        port: (0, superstruct_1.defaulted)((0, superstruct_1.number)(), 8081),
    }), {}),
    environment: (0, superstruct_1.defaulted)((0, superstruct_1.record)((0, superstruct_1.string)(), (0, superstruct_1.unknown)()), {}),
    stats: (0, superstruct_1.defaulted)((0, superstruct_1.object)({
        verbose: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
        builtIns: (0, superstruct_1.defaulted)((0, snaps_sdk_1.union)([
            (0, superstruct_1.object)({ ignore: (0, superstruct_1.defaulted)((0, superstruct_1.array)((0, superstruct_1.string)()), []) }),
            (0, snaps_sdk_1.literal)(false),
        ]), {}),
        buffer: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), true),
    }), {}),
    polyfills: (0, superstruct_1.defaulted)((0, snaps_sdk_1.union)([
        (0, superstruct_1.boolean)(),
        (0, superstruct_1.object)({
            assert: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            buffer: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            console: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            constants: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            crypto: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            domain: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            events: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            http: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            https: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            os: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            path: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            punycode: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            process: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            querystring: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            stream: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            /* eslint-disable @typescript-eslint/naming-convention */
            _stream_duplex: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            _stream_passthrough: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            _stream_readable: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            _stream_transform: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            _stream_writable: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            string_decoder: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            /* eslint-enable @typescript-eslint/naming-convention */
            sys: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            timers: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            tty: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            url: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            util: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            vm: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
            zlib: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
        }),
    ]), false),
    typescript: (0, superstruct_1.defaulted)((0, superstruct_1.object)({
        enabled: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
        configFile: (0, superstruct_1.defaulted)((0, structs_1.file)(), 'tsconfig.json'),
    }), {}),
    features: (0, superstruct_1.defaulted)((0, superstruct_1.object)({
        images: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), true),
    }), {}),
    customizeWebpackConfig: (0, superstruct_1.optional)(SnapsWebpackCustomizeWebpackConfigFunctionStruct),
    experimental: (0, superstruct_1.defaulted)((0, superstruct_1.object)({
        wasm: (0, superstruct_1.defaulted)((0, superstruct_1.boolean)(), false),
    }), {}),
});
exports.SnapsConfigStruct = (0, superstruct_1.type)({
    bundler: (0, superstruct_1.defaulted)((0, snaps_sdk_1.union)([(0, snaps_sdk_1.literal)('browserify'), (0, snaps_sdk_1.literal)('webpack')]), 'webpack'),
});
exports.LegacyOptionsStruct = (0, snaps_sdk_1.union)([
    (0, node_1.named)('object with `transpilationMode` set to `localAndDeps` and `depsToTranspile` set to an array of strings', (0, superstruct_1.type)({
        depsToTranspile: (0, superstruct_1.array)((0, superstruct_1.string)()),
        transpilationMode: (0, snaps_sdk_1.literal)(builders_1.TranspilationModes.LocalAndDeps),
        writeManifest: (0, superstruct_1.boolean)(),
        bundlerCustomizer: (0, superstruct_1.optional)(SnapsBrowserifyBundlerCustomizerFunctionStruct),
    })),
    (0, node_1.named)('object without `depsToTranspile`', (0, superstruct_1.type)({
        depsToTranspile: (0, node_1.named)('empty array', (0, superstruct_1.empty)((0, superstruct_1.array)())),
        transpilationMode: (0, snaps_sdk_1.union)([
            (0, snaps_sdk_1.literal)(builders_1.TranspilationModes.LocalOnly),
            (0, snaps_sdk_1.literal)(builders_1.TranspilationModes.None),
        ]),
        writeManifest: (0, superstruct_1.boolean)(),
        bundlerCustomizer: (0, superstruct_1.optional)(SnapsBrowserifyBundlerCustomizerFunctionStruct),
    })),
]);
/**
 * Get a validated snap config. This validates the config and adds default
 * values for any missing properties.
 *
 * @param config - The config to validate.
 * @param argv - The CLI arguments.
 * @returns The validated config.
 */
function getConfig(config, argv) {
    const prefix = 'The snap config file is invalid';
    const suffix = (0, chalk_1.dim)('Refer to the documentation for more information: https://docs.metamask.io/snaps/reference/cli/options/');
    const { bundler } = (0, node_1.createFromStruct)(config, exports.SnapsConfigStruct, prefix, suffix);
    if (bundler === 'browserify') {
        const legacyConfig = (0, node_1.createFromStruct)(config, exports.SnapsBrowserifyConfigStruct, prefix, suffix);
        return getWebpackConfig(mergeLegacyOptions(argv, legacyConfig));
    }
    return (0, node_1.createFromStruct)(config, exports.SnapsWebpackConfigStruct, prefix, suffix);
}
exports.getConfig = getConfig;
/**
 * Load a snap config from a file. This supports both JavaScript and TypeScript
 * config files, in the CommonJS module format and the ES module format.
 *
 * This assumes that the config file exports a default object, either through
 * `module.exports` or `export default`.
 *
 * @param path - The full path to the config file.
 * @param argv - The CLI arguments.
 * @returns The validated config.
 * @throws If the config file is invalid, or if the config file does not have a
 * default export.
 */
async function loadConfig(path, argv) {
    try {
        const contents = await (0, promises_1.readFile)(path, 'utf8');
        const source = await (0, core_1.transform)(contents, {
            swcrc: false,
            jsc: {
                parser: {
                    syntax: 'typescript',
                },
            },
            module: {
                type: 'commonjs',
            },
        });
        const config = new module_1.default(path);
        // @ts-expect-error - This function is not typed.
        config.paths = module_1.default._nodeModulePaths((0, path_1.dirname)(path));
        // @ts-expect-error - This function is not typed.
        config._compile(source.code, path);
        if (!(0, utils_1.hasProperty)(config.exports, 'default')) {
            return getConfig(config.exports, argv);
        }
        return getConfig(config.exports.default, argv);
    }
    catch (error) {
        if (error instanceof node_1.SnapsStructError) {
            throw new errors_1.ConfigError(error.message);
        }
        throw new errors_1.ConfigError(`Unable to load snap config file at "${path}".\n\n${(0, node_1.indent)(error.message)}`);
    }
}
exports.loadConfig = loadConfig;
/**
 * Resolve a snap config. This function will look for a `snap.config.js` or
 * `snap.config.ts` file in the current or specified directory.
 *
 * @param path - The path to resolve the snap config from. Defaults to the
 * current working directory.
 * @param argv - The CLI arguments.
 * @returns The resolved and validated snap config.
 * @throws If a snap config could not be found.
 */
async function resolveConfig(path, argv) {
    for (const configFile of CONFIG_FILES) {
        const filePath = (0, path_1.resolve)(path, configFile);
        if (await (0, node_1.isFile)(filePath)) {
            return await loadConfig(filePath, argv);
        }
    }
    throw new errors_1.ConfigError(`Could not find a "snap.config.js" or "snap.config.ts" file in the current or specified directory ("${path}").`);
}
exports.resolveConfig = resolveConfig;
/**
 * Get a snap config from the CLI arguments. This will either load the config
 * from the specified config file, or resolve the config from the current
 * working directory.
 *
 * @param argv - The CLI arguments.
 * @param cwd - The current working directory. Defaults to `process.cwd()`.
 * @returns The resolved and validated snap config.
 */
async function getConfigByArgv(argv, cwd = process.cwd()) {
    if (argv.config) {
        if (!(await (0, node_1.isFile)(argv.config))) {
            throw new errors_1.ConfigError(`Could not find a config file at "${argv.config}". Make sure that the path is correct.`);
        }
        return await loadConfig(argv.config, argv);
    }
    return await resolveConfig(cwd, argv);
}
exports.getConfigByArgv = getConfigByArgv;
/**
 * Merge legacy CLI options into the config. This is used to support the legacy
 * config format, where options can be specified both in the config file and
 * through CLI flags.
 *
 * @param argv - The CLI arguments.
 * @param config - The config to merge the CLI options into.
 * @returns The config with the CLI options merged in.
 * @deprecated This function is only used to support the legacy config format.
 */
function mergeLegacyOptions(argv, config) {
    const cliOptions = Object.keys(config.cliOptions).reduce((accumulator, key) => {
        if (argv[key] !== undefined) {
            return {
                ...accumulator,
                [key]: argv[key],
            };
        }
        return accumulator;
    }, config.cliOptions);
    return {
        ...config,
        cliOptions,
    };
}
exports.mergeLegacyOptions = mergeLegacyOptions;
/**
 * Get a Webpack config from a legacy browserify config. This is used to
 * support the legacy config format, and convert it to the new format.
 *
 * @param legacyConfig - The legacy browserify config.
 * @returns The Webpack config.
 */
function getWebpackConfig(legacyConfig) {
    const defaultConfig = (0, superstruct_1.create)({ bundler: 'webpack' }, exports.SnapsWebpackConfigStruct);
    // The legacy config has two options for specifying the output path and
    // filename: `bundle`, and `dist` + `outfileName`. If `bundle` is specified,
    // we use that as the output path and filename. Otherwise, we use `dist` and
    // `outfileName`.
    const path = legacyConfig.cliOptions.bundle
        ? (0, path_1.dirname)(legacyConfig.cliOptions.bundle)
        : legacyConfig.cliOptions.dist;
    const filename = legacyConfig.cliOptions.bundle
        ? (0, path_1.basename)(legacyConfig.cliOptions.bundle)
        : legacyConfig.cliOptions.outfileName;
    return {
        ...defaultConfig,
        input: legacyConfig.cliOptions.src,
        evaluate: legacyConfig.cliOptions.eval,
        sourceMap: legacyConfig.cliOptions.sourceMaps,
        output: {
            path,
            filename,
            // The legacy config has an option to remove comments from the bundle, but
            // the terser plugin does this by default, so we only enable the terser if
            // the legacy config has `stripComments` set to `true`. This is not a
            // perfect solution, but it's the best we can do without breaking the
            // legacy config.
            minimize: legacyConfig.cliOptions.stripComments,
            // The legacy config does not have a `clean` option, so we default to
            // `false` here.
            clean: false,
        },
        manifest: {
            // The legacy config does not have a `manifest` option, so we default to
            // `process.cwd()/snap.manifest.json`.
            path: (0, path_1.resolve)(process.cwd(), 'snap.manifest.json'),
            update: legacyConfig.cliOptions.writeManifest,
        },
        server: {
            enabled: legacyConfig.cliOptions.serve,
            port: legacyConfig.cliOptions.port,
            root: legacyConfig.cliOptions.root,
        },
        stats: {
            verbose: false,
            // These plugins are designed to be used with the modern config format, so
            // we disable them for the legacy config format.
            builtIns: false,
            buffer: false,
        },
        legacy: (0, node_1.createFromStruct)({
            ...legacyConfig.cliOptions,
            bundlerCustomizer: legacyConfig.bundlerCustomizer,
        }, exports.LegacyOptionsStruct, 'Invalid Browserify CLI options'),
    };
}
exports.getWebpackConfig = getWebpackConfig;
//# sourceMappingURL=config.cjs.map