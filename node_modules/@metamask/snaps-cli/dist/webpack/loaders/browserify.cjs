"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const browserify_1 = __importDefault(require("browserify"));
const readable_stream_1 = require("readable-stream");
const builders_1 = require("../../builders.cjs");
const utils_1 = require("../../utils/index.cjs");
const utils_2 = require("../utils.cjs");
/**
 * A Browserify loader for Webpack. This exists for backwards compatibility with
 * the legacy configuration format, in order to support the `bundlerCustomizer`
 * function.
 *
 * When this loader is used, the input file will be processed by Browserify, and
 * written to disk by Webpack. Most processing will be handled by Browserify, so
 * there are no benefits like tree-shaking.
 *
 * @param content - The input file contents as a string.
 * @param sourceMap - The source map of the input file.
 * @returns The Browserify loader.
 */
const loader = async function (content, sourceMap) {
    const config = this.getOptions();
    const { transpilationMode } = config;
    const bundler = (0, browserify_1.default)({
        extensions: ['.js', '.jsx', '.ts', '.tsx'],
        debug: Boolean(sourceMap),
        standalone: '<snap>',
    });
    if (transpilationMode !== builders_1.TranspilationModes.None) {
        const babelifyOptions = (0, utils_1.processDependencies)(config);
        // We need to statically import all Browserify transforms, and all Babel
        // presets and plugins, and calling `require` is the sanest way to do that.
        /* eslint-disable @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires, n/global-require */
        bundler.transform(require("babelify/index.js"), {
            global: transpilationMode === builders_1.TranspilationModes.LocalAndDeps,
            extensions: ['.js', '.jsx', '.ts', '.tsx'],
            presets: [
                require("@babel/preset-typescript"),
                [
                    require("@babel/preset-env"),
                    {
                        targets: {
                            browsers: await (0, utils_2.getBrowserslistTargets)(),
                        },
                    },
                ],
            ],
            plugins: [
                require("@babel/plugin-transform-runtime"),
                require("@babel/plugin-transform-class-properties"),
                require("@babel/plugin-transform-private-methods"),
                require("@babel/plugin-transform-class-static-block"),
                require("@babel/plugin-transform-private-property-in-object"),
            ],
            ...babelifyOptions,
        });
        /* eslint-enable @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires, n/global-require */
    }
    config.bundlerCustomizer?.(bundler);
    // Browserify doesn't accept a string as an entry point, so we need to convert
    // it to a stream.
    const stream = new readable_stream_1.Readable();
    stream.push(content);
    stream.push(null);
    bundler.add(stream, {
        file: this.resourcePath,
    });
    return new Promise((resolve, reject) => {
        bundler.bundle((bundleError, buffer) => {
            if (bundleError) {
                reject(bundleError);
                return;
            }
            // Browserify inlines the source map, so we just pass the output buffer back
            // to Webpack.
            resolve(buffer);
        });
    });
};
exports.default = loader;
//# sourceMappingURL=browserify.cjs.map