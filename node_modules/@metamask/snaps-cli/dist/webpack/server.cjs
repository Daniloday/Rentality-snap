"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getServer = exports.getAllowedPaths = void 0;
const node_1 = require("@metamask/snaps-utils/node");
const http_1 = require("http");
const path_1 = require("path");
const serve_handler_1 = __importDefault(require("serve-handler"));
/**
 * Get the relative path from one path to another.
 *
 * Note: This is a modified version of `path.relative` that uses Posix
 * separators for URL-compatibility.
 *
 * @param from - The path to start from.
 * @param to - The path to end at.
 * @returns The relative path.
 */
function getRelativePath(from, to) {
    return (0, path_1.relative)(from, to).split(path_1.sep).join(path_1.posix.sep);
}
/**
 * Get the allowed paths for the static server. This includes the output file,
 * the manifest file, and any auxiliary/localization files.
 *
 * @param config - The config object.
 * @param manifest - The Snap manifest object.
 * @returns An array of allowed paths.
 */
function getAllowedPaths(config, manifest) {
    const auxiliaryFiles = manifest.source.files?.map((file) => getRelativePath(config.server.root, (0, path_1.resolve)(config.server.root, file))) ?? [];
    const localizationFiles = manifest.source.locales?.map((localization) => getRelativePath(config.server.root, (0, path_1.resolve)(config.server.root, localization))) ?? [];
    const otherFiles = manifest.source.location.npm.iconPath
        ? [
            getRelativePath(config.server.root, (0, path_1.resolve)(config.server.root, manifest.source.location.npm.iconPath)),
        ]
        : [];
    return [
        getRelativePath(config.server.root, (0, path_1.resolve)(config.server.root, config.output.path, config.output.filename)),
        getRelativePath(config.server.root, (0, path_1.resolve)(config.server.root, node_1.NpmSnapFileNames.Manifest)),
        ...auxiliaryFiles,
        ...localizationFiles,
        ...otherFiles,
    ];
}
exports.getAllowedPaths = getAllowedPaths;
/**
 * Get a static server for development purposes.
 *
 * Note: We're intentionally not using `webpack-dev-server` here because it
 * adds a lot of extra stuff to the output that we don't need, and it's
 * difficult to customize.
 *
 * @param config - The config object.
 * @returns An object with a `listen` method that returns a promise that
 * resolves when the server is listening.
 */
function getServer(config) {
    /**
     * Get the response for a request. This is extracted into a function so that
     * we can easily catch errors and send a 500 response.
     *
     * @param request - The request.
     * @param response - The response.
     * @returns A promise that resolves when the response is sent.
     */
    async function getResponse(request, response) {
        const manifestPath = (0, path_1.join)(config.server.root, node_1.NpmSnapFileNames.Manifest);
        const { result } = await (0, node_1.readJsonFile)(manifestPath);
        const allowedPaths = getAllowedPaths(config, result);
        const pathname = request.url &&
            request.headers.host &&
            new URL(request.url, `http://${request.headers.host}`).pathname;
        const path = pathname?.slice(1);
        const allowed = allowedPaths.some((allowedPath) => path === allowedPath);
        if (!allowed) {
            response.statusCode = 404;
            response.end();
            return;
        }
        await (0, serve_handler_1.default)(request, response, {
            public: config.server.root,
            directoryListing: false,
            headers: [
                {
                    source: '**/*',
                    headers: [
                        {
                            key: 'Cache-Control',
                            value: 'no-cache',
                        },
                        {
                            key: 'Access-Control-Allow-Origin',
                            value: '*',
                        },
                    ],
                },
            ],
        });
    }
    const server = (0, http_1.createServer)((request, response) => {
        getResponse(request, response).catch(
        /* istanbul ignore next */
        (error) => {
            (0, node_1.logError)(error);
            response.statusCode = 500;
            response.end();
        });
    });
    /**
     * Start the server on the port specified in the config.
     *
     * @param port - The port to listen on.
     * @returns A promise that resolves when the server is listening. The promise
     * resolves to an object with the port and the server instance. Note that if
     * the `config.server.port` is `0`, the OS will choose a random port for us,
     * so we need to get the port from the server after it starts.
     */
    const listen = async (port = config.server.port) => {
        return new Promise((resolve, reject) => {
            try {
                server.listen(port, () => {
                    const close = async () => {
                        await new Promise((resolveClose, rejectClose) => {
                            server.close((closeError) => {
                                if (closeError) {
                                    return rejectClose(closeError);
                                }
                                return resolveClose();
                            });
                        });
                    };
                    const address = server.address();
                    resolve({ port: address.port, server, close });
                });
            }
            catch (listenError) {
                reject(listenError);
            }
        });
    };
    return { listen };
}
exports.getServer = getServer;
//# sourceMappingURL=server.cjs.map