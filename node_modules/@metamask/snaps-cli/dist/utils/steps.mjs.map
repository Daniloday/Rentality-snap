{"version":3,"file":"steps.mjs","sourceRoot":"","sources":["../../src/utils/steps.ts"],"names":[],"mappings":";;;;;;;;AAEA,OAAO,cAAa,qBAAY;;AAEhC,OAAO,EAAE,eAAe,EAAE,qBAAiB;AAC3C,OAAO,EAAE,KAAK,EAAE,sBAAkB;AAYlC;;;;;;GAMG;AACH,MAAM,CAAC,KAAK,UAAU,YAAY,CAChC,KAAqB,EACrB,OAAgB;IAEhB,MAAM,OAAO,GAAG,aAAa,CAAC;QAC5B,6CAA6C;QAC7C,MAAM,EAAE,OAAO,CAAC,MAAM;KACvB,CAAC,CAAC;IAEH,OAAO,CAAC,KAAK,EAAE,CAAC;IAEhB,IAAI,CAAC;QACH,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;YACzB,uEAAuE;YACvE,IAAI,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,CAAC;gBAC/C,SAAS;YACX,CAAC;YAED,uEAAuE;YACvE,8CAA8C;YAC9C,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAE9B,MAAM,IAAI,CAAC,IAAI,CAAC;gBACd,GAAG,OAAO;gBACV,OAAO;aACR,CAAC,CAAC;QACL,CAAC;QAED,0EAA0E;QAC1E,kBAAkB;QAClB,IAAI,OAAO,CAAC,UAAU,EAAE,CAAC;YACvB,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QAC3B,CAAC;IACH,CAAC;IAAC,OAAO,MAAM,EAAE,CAAC;QAChB,KAAK,CAAC,eAAe,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,CAAC;QACxC,OAAO,CAAC,IAAI,EAAE,CAAC;QACf,OAAO,CAAC,QAAQ,GAAG,CAAC,CAAC;IACvB,CAAC;AACH,CAAC","sourcesContent":["import { dim } from 'chalk';\nimport type { Ora } from 'ora';\nimport createSpinner from 'ora';\n\nimport { getErrorMessage } from './errors';\nimport { error } from './logging';\n\nexport type Step<Context extends Record<string, unknown>> = {\n  name: string;\n  condition?: (context: Context) => boolean;\n  task: (context: Context & { spinner: Ora }) => Promise<void>;\n};\n\nexport type Steps<Context extends Record<string, unknown>> = Readonly<\n  Step<Context>[]\n>;\n\n/**\n * Execute a list of steps in series. Each step receives the context object and\n * a spinner instance.\n *\n * @param steps - The steps to execute.\n * @param context - The context object that will be passed to each step.\n */\nexport async function executeSteps<Context extends Record<string, unknown>>(\n  steps: Steps<Context>,\n  context: Context,\n) {\n  const spinner = createSpinner({\n    // Ora writes to `process.stderr` by default.\n    stream: process.stdout,\n  });\n\n  spinner.start();\n\n  try {\n    for (const step of steps) {\n      // If the step has a condition, and it returns false, we skip the step.\n      if (step.condition && !step.condition(context)) {\n        continue;\n      }\n\n      // Calling `start` here instead of setting `spinner.text` seems to work\n      // better when the process doesn't have a TTY.\n      spinner.start(dim(step.name));\n\n      await step.task({\n        ...context,\n        spinner,\n      });\n    }\n\n    // The spinner may have been stopped by a step, so we only succeed if it's\n    // still spinning.\n    if (spinner.isSpinning) {\n      spinner.succeed('Done!');\n    }\n  } catch (_error) {\n    error(getErrorMessage(_error), spinner);\n    spinner.stop();\n    process.exitCode = 1;\n  }\n}\n"]}