"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeSteps = void 0;
const chalk_1 = require("chalk");
const ora_1 = __importDefault(require("ora/index.js"));
const errors_1 = require("./errors.cjs");
const logging_1 = require("./logging.cjs");
/**
 * Execute a list of steps in series. Each step receives the context object and
 * a spinner instance.
 *
 * @param steps - The steps to execute.
 * @param context - The context object that will be passed to each step.
 */
async function executeSteps(steps, context) {
    const spinner = (0, ora_1.default)({
        // Ora writes to `process.stderr` by default.
        stream: process.stdout,
    });
    spinner.start();
    try {
        for (const step of steps) {
            // If the step has a condition, and it returns false, we skip the step.
            if (step.condition && !step.condition(context)) {
                continue;
            }
            // Calling `start` here instead of setting `spinner.text` seems to work
            // better when the process doesn't have a TTY.
            spinner.start((0, chalk_1.dim)(step.name));
            await step.task({
                ...context,
                spinner,
            });
        }
        // The spinner may have been stopped by a step, so we only succeed if it's
        // still spinning.
        if (spinner.isSpinning) {
            spinner.succeed('Done!');
        }
    }
    catch (_error) {
        (0, logging_1.error)((0, errors_1.getErrorMessage)(_error), spinner);
        spinner.stop();
        process.exitCode = 1;
    }
}
exports.executeSteps = executeSteps;
//# sourceMappingURL=steps.cjs.map