"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.manifest = void 0;
const node_1 = require("@metamask/snaps-utils/node");
const snaps_webpack_plugin_1 = require("@metamask/snaps-webpack-plugin");
const utils_1 = require("@metamask/utils");
const chalk_1 = require("chalk");
const path_1 = require("path");
const utils_2 = require("../../utils/index.cjs");
/**
 * Check the snap manifest file at the given path. If `write` is `true`, the
 * manifest will be written to disk if it is invalid. If `write` is `false`,
 * the manifest will not be written to disk, and the function will log any
 * errors and warnings to the console.
 *
 * @param path - The path to the manifest file.
 * @param write - Whether to write the manifest to disk if it is invalid.
 * @param spinner - An optional spinner to use for logging.
 * @returns Whether the manifest is valid.
 */
async function manifest(path, write, spinner) {
    const { reports, updated } = await (0, node_1.checkManifest)((0, path_1.dirname)(path), {
        updateAndWriteManifest: write,
        writeFileFn: snaps_webpack_plugin_1.writeManifest,
    });
    const errors = [];
    const fixed = [];
    const warnings = [];
    for (const report of reports) {
        if (report.severity === 'error' && !report.wasFixed) {
            errors.push((0, node_1.indent)((0, chalk_1.red)(`• ${report.message}`)));
        }
        else if (report.wasFixed) {
            fixed.push((0, node_1.indent)((0, chalk_1.yellow)(`• ${report.message}`) + (0, chalk_1.green)(' (fixed)')));
        }
        else {
            (0, utils_1.assert)(report.severity === 'warning');
            warnings.push((0, node_1.indent)((0, chalk_1.yellow)(`• ${report.message}`)));
        }
    }
    if (errors.length > 0) {
        const formattedErrors = errors.join('\n');
        let message = `The snap manifest file is invalid.\n\n${formattedErrors}`;
        if (!write) {
            message +=
                '\n\nRun the command with the `--fix` flag to attempt to fix the manifest.';
        }
        (0, utils_2.error)(message, spinner);
    }
    if (write && updated) {
        const formattedFixed = fixed.join('\n');
        (0, utils_2.info)(`The snap manifest file has been updated.\n\n${formattedFixed}`, spinner);
    }
    if (warnings.length > 0) {
        const formattedWarnings = warnings.join('\n');
        (0, utils_2.warn)(`The snap manifest file has warnings.\n\n${formattedWarnings}`, spinner);
    }
    if (errors.length > 0) {
        spinner?.stop();
        process.exitCode = 1;
        return false;
    }
    return true;
}
exports.manifest = manifest;
//# sourceMappingURL=implementation.cjs.map