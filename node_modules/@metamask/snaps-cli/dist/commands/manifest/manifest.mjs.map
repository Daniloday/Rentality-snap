{"version":3,"file":"manifest.mjs","sourceRoot":"","sources":["../../../src/commands/manifest/manifest.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,mCAAmC;AAGpD,OAAO,EAAE,YAAY,EAAE,yBAAqB;AAE5C,OAAO,EAAE,YAAY,EAAE,8BAAoB;AAC3C,OAAO,EAAE,QAAQ,EAAE,6BAAyB;AAY5C,MAAM,KAAK,GAA2B;IACpC;QACE,IAAI,EAAE,0BAA0B;QAChC,IAAI,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE;YACxB,IAAI,CAAC,CAAC,MAAM,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;gBAC3B,MAAM,IAAI,YAAY,CACpB,6BAA6B,KAAK,2DAA2D,CAC9F,CAAC;YACJ,CAAC;QACH,CAAC;KACF;IACD;QACE,IAAI,EAAE,+BAA+B;QACrC,IAAI,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,EAAE,EAAE;YAClD,MAAM,KAAK,GAAG,gBAAgB,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;YAChD,MAAM,KAAK,GAAG,MAAM,QAAQ,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YAEpD,IAAI,KAAK,EAAE,CAAC;gBACV,OAAO,CAAC,OAAO,CAAC,kCAAkC,CAAC,CAAC;YACtD,CAAC;QACH,CAAC;KACF;CACF,CAAC;AAEF;;;;;;GAMG;AACH,SAAS,gBAAgB,CAAC,MAAuB,EAAE,OAAwB;IACzE,IAAI,OAAO,OAAO,CAAC,GAAG,KAAK,SAAS,EAAE,CAAC;QACrC,OAAO,OAAO,CAAC,GAAG,CAAC;IACrB,CAAC;IAED,OAAO,MAAM,CAAC,MAAM,EAAE,aAAa,IAAI,KAAK,CAAC;AAC/C,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,CAAC,KAAK,UAAU,eAAe,CACnC,MAAuB,EACvB,OAAwB;IAExB,MAAM,YAAY,CAAC,KAAK,EAAE;QACxB,KAAK,EAAE,MAAM,CAAC,QAAQ,CAAC,IAAI;QAC3B,MAAM;QACN,OAAO;KACR,CAAC,CAAC;AACL,CAAC","sourcesContent":["import { isFile } from '@metamask/snaps-utils/node';\n\nimport type { ProcessedConfig } from '../../config';\nimport { CommandError } from '../../errors';\nimport type { Steps } from '../../utils';\nimport { executeSteps } from '../../utils';\nimport { manifest } from './implementation';\n\ntype ManifestOptions = {\n  fix?: boolean;\n};\n\ntype ManifestContext = {\n  input: string;\n  config: ProcessedConfig;\n  options: ManifestOptions;\n};\n\nconst steps: Steps<ManifestContext> = [\n  {\n    name: 'Checking the input file.',\n    task: async ({ input }) => {\n      if (!(await isFile(input))) {\n        throw new CommandError(\n          `Manifest file not found: \"${input}\". Make sure that the \\`snap.manifest.json\\` file exists.`,\n        );\n      }\n    },\n  },\n  {\n    name: 'Validating the snap manifest.',\n    task: async ({ input, config, options, spinner }) => {\n      const write = getWriteManifest(config, options);\n      const valid = await manifest(input, write, spinner);\n\n      if (valid) {\n        spinner.succeed('The snap manifest file is valid.');\n      }\n    },\n  },\n];\n\n/**\n * Get whether to write the manifest to disk.\n *\n * @param config - The config object.\n * @param options - The options object.\n * @returns Whether to write the manifest to disk.\n */\nfunction getWriteManifest(config: ProcessedConfig, options: ManifestOptions) {\n  if (typeof options.fix === 'boolean') {\n    return options.fix;\n  }\n\n  return config.legacy?.writeManifest ?? false;\n}\n\n/**\n * Validates a snap.manifest.json file. Attempts to fix the manifest and write\n * the fixed version to disk if `writeManifest` is true. Throws if validation\n * fails.\n *\n * @param config - The config object.\n * @param options - The options object.\n */\nexport async function manifestHandler(\n  config: ProcessedConfig,\n  options: ManifestOptions,\n) {\n  await executeSteps(steps, {\n    input: config.manifest.path,\n    config,\n    options,\n  });\n}\n"]}