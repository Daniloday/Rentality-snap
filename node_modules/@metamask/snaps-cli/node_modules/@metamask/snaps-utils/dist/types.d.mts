import type { Infer, Struct } from "@metamask/superstruct";
import type { Json } from "@metamask/utils";
import type { SnapCaveatType } from "./caveats.mjs";
import type { SnapFunctionExports, SnapRpcHookArgs } from "./handlers.mjs";
import type { LocalizationFile } from "./localization.mjs";
import type { SnapManifest } from "./manifest/index.mjs";
import type { VirtualFile } from "./virtual-file/index.mjs";
export declare enum NpmSnapFileNames {
    PackageJson = "package.json",
    Manifest = "snap.manifest.json"
}
export declare const NameStruct: Struct<string, null>;
export declare const NpmSnapPackageJsonStruct: Struct<{
    name: string;
    version: import("@metamask/utils").SemVerVersion;
    main?: string | undefined;
    repository?: {
        type: string;
        url: string;
    } | undefined;
}, {
    version: Struct<import("@metamask/utils").SemVerVersion, null>;
    name: Struct<string, null>;
    main: Struct<string | undefined, null>;
    repository: Struct<{
        type: string;
        url: string;
    } | undefined, {
        type: Struct<string, null>;
        url: Struct<string, null>;
    }>;
}>;
export type NpmSnapPackageJson = Infer<typeof NpmSnapPackageJsonStruct> & Record<string, any>;
/**
 * An object for storing parsed but unvalidated Snap file contents.
 */
export type UnvalidatedSnapFiles = {
    manifest?: VirtualFile<Json>;
    packageJson?: VirtualFile<Json>;
    sourceCode?: VirtualFile;
    svgIcon?: VirtualFile;
    auxiliaryFiles: VirtualFile[];
    localizationFiles: VirtualFile[];
};
/**
 * An object for storing the contents of Snap files that have passed JSON
 * Schema validation, or are non-empty if they are strings.
 */
export type SnapFiles = {
    manifest: VirtualFile<SnapManifest>;
    packageJson: VirtualFile<NpmSnapPackageJson>;
    sourceCode: VirtualFile;
    svgIcon?: VirtualFile;
    auxiliaryFiles: VirtualFile[];
    localizationFiles: VirtualFile<LocalizationFile>[];
};
/**
 * A subset of snap files extracted from a fetched snap.
 */
export type FetchedSnapFiles = Pick<SnapFiles, 'manifest' | 'sourceCode' | 'svgIcon' | 'auxiliaryFiles' | 'localizationFiles'>;
/**
 * The possible prefixes for snap ids.
 */
export declare enum SnapIdPrefixes {
    npm = "npm:",
    local = "local:"
}
export declare enum SNAP_STREAM_NAMES {
    JSON_RPC = "jsonRpc",
    COMMAND = "command"
}
export type SnapRpcHook = (options: SnapRpcHookArgs) => Promise<unknown>;
type ObjectParameters<Type extends Record<string, (...args: any[]) => unknown>> = Parameters<Type[keyof Type]>;
export type SnapExportsParameters = ObjectParameters<SnapFunctionExports>;
type UriOptions<Type extends string> = {
    protocol?: Struct<Type>;
    hash?: Struct<Type>;
    port?: Struct<Type>;
    hostname?: Struct<Type>;
    pathname?: Struct<Type>;
    search?: Struct<Type>;
};
export declare const uri: (opts?: UriOptions<any>) => Struct<string | URL, null>;
/**
 * Returns whether a given value is a valid URL.
 *
 * @param url - The value to check.
 * @param opts - Optional constraints for url checking.
 * @returns Whether `url` is valid URL or not.
 */
export declare function isValidUrl(url: unknown, opts?: UriOptions<any>): url is string | URL;
export declare const WALLET_SNAP_PERMISSION_KEY = "wallet_snap";
export type SnapsPermissionRequest = {
    [WALLET_SNAP_PERMISSION_KEY]: {
        caveats: [
            {
                type: SnapCaveatType.SnapIds;
                value: Record<string, Json>;
            }
        ];
    };
};
export {};
//# sourceMappingURL=types.d.mts.map