function $__filename(fileUrl) {
    const url = new URL(fileUrl);
    return url.pathname.replace(/^\/([a-zA-Z]:)/u, "$1");
}
function $getDirname(path) {
    const sanitisedPath = path.toString().replace(/\\/gu, "/").replace(/\/$/u, "");
    const index = sanitisedPath.lastIndexOf("/");
    if (index === -1) {
        return path;
    }
    if (index === 0) {
        return "/";
    }
    return sanitisedPath.slice(0, index);
}
function $__dirname(url) {
    return $getDirname($__filename(url));
}
import { assert } from "@metamask/utils";
import { fork } from "child_process";
import { join } from "path";
import { validateFilePath } from "./fs.mjs";
export class SnapEvalError extends Error {
    constructor(message, output) {
        super(message);
        this.name = 'SnapEvalError';
        this.output = output;
    }
}
/**
 * Spawn a new process to run the provided bundle in.
 *
 * @param bundlePath - The path to the bundle to run.
 * @returns `null` if the worker ran successfully.
 * @throws If the worker failed to run successfully.
 */
export async function evalBundle(bundlePath) {
    await validateFilePath(bundlePath);
    return new Promise((resolve, reject) => {
        const worker = fork(join($__dirname(import.meta.url), 'eval-worker.cjs'), [bundlePath], {
            // To avoid printing the output of the worker to the console, we set
            // `stdio` to `pipe` and handle the output ourselves.
            stdio: 'pipe',
        });
        let stdout = '';
        let stderr = '';
        assert(worker.stdout, '`stdout` should be defined.');
        assert(worker.stderr, '`stderr` should be defined.');
        worker.stdout.on('data', (data) => {
            stdout += data.toString();
        });
        worker.stderr.on('data', (data) => {
            stderr += data.toString();
        });
        worker.on('exit', (exitCode) => {
            const output = {
                stdout,
                stderr,
            };
            if (exitCode === 0) {
                return resolve(output);
            }
            return reject(new SnapEvalError(`Process exited with non-zero exit code: ${exitCode}.`, output));
        });
    });
}
//# sourceMappingURL=eval.mjs.map