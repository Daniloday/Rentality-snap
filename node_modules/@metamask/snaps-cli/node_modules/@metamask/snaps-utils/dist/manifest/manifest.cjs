"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWritableManifest = exports.getSnapFiles = exports.getSnapFilePaths = exports.getSnapIcon = exports.getSnapSourceCode = exports.runFixes = exports.checkManifest = void 0;
const snaps_sdk_1 = require("@metamask/snaps-sdk");
const utils_1 = require("@metamask/utils");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const deep_clone_1 = require("../deep-clone.cjs");
const fs_2 = require("../fs.cjs");
const json_1 = require("../json.cjs");
const types_1 = require("../types.cjs");
const node_1 = require("../virtual-file/node.cjs");
const validator_1 = require("./validator.cjs");
const MANIFEST_SORT_ORDER = {
    $schema: 1,
    version: 2,
    description: 3,
    proposedName: 4,
    repository: 5,
    source: 6,
    initialConnections: 7,
    initialPermissions: 8,
    platformVersion: 9,
    manifestVersion: 10,
};
/**
 * Validates a snap.manifest.json file. Attempts to fix the manifest and write
 * the fixed version to disk if `writeManifest` is true. Throws if validation
 * fails.
 *
 * @param basePath - The path to the folder with the manifest files.
 * @param options - Additional options for the function.
 * @param options.sourceCode - The source code of the Snap.
 * @param options.writeFileFn - The function to use to write the manifest to disk.
 * @param options.updateAndWriteManifest - Whether to auto-magically try to fix errors and then write the manifest to disk.
 * @returns Whether the manifest was updated, and an array of warnings that
 * were encountered during processing of the manifest files.
 */
async function checkManifest(basePath, { updateAndWriteManifest = true, sourceCode, writeFileFn = fs_1.promises.writeFile, } = {}) {
    const manifestPath = path_1.default.join(basePath, types_1.NpmSnapFileNames.Manifest);
    const manifestFile = await (0, fs_2.readJsonFile)(manifestPath);
    const unvalidatedManifest = manifestFile.result;
    const packageFile = await (0, fs_2.readJsonFile)(path_1.default.join(basePath, types_1.NpmSnapFileNames.PackageJson));
    const auxiliaryFilePaths = getSnapFilePaths(unvalidatedManifest, (manifest) => manifest?.source?.files);
    const localizationFilePaths = getSnapFilePaths(unvalidatedManifest, (manifest) => manifest?.source?.locales);
    const localizationFiles = (await getSnapFiles(basePath, localizationFilePaths)) ?? [];
    for (const localization of localizationFiles) {
        try {
            localization.result = (0, json_1.parseJson)(localization.toString());
        }
        catch (error) {
            (0, utils_1.assert)(error instanceof SyntaxError, error);
            throw new Error(`Failed to parse localization file "${localization.path}" as JSON.`);
        }
    }
    const snapFiles = {
        manifest: manifestFile,
        packageJson: packageFile,
        sourceCode: await getSnapSourceCode(basePath, unvalidatedManifest, sourceCode),
        svgIcon: await getSnapIcon(basePath, unvalidatedManifest),
        // Intentionally pass null as the encoding here since the files may be binary
        auxiliaryFiles: (await getSnapFiles(basePath, auxiliaryFilePaths, null)) ?? [],
        localizationFiles,
    };
    const validatorResults = await (0, validator_1.runValidators)(snapFiles);
    let manifestResults = {
        updated: false,
        files: validatorResults.files,
        reports: validatorResults.reports,
    };
    if (updateAndWriteManifest && (0, validator_1.hasFixes)(manifestResults)) {
        const fixedResults = await runFixes(validatorResults);
        if (fixedResults.updated) {
            manifestResults = fixedResults;
            (0, utils_1.assert)(manifestResults.files);
            try {
                await writeFileFn(path_1.default.join(basePath, types_1.NpmSnapFileNames.Manifest), manifestResults.files.manifest.toString());
            }
            catch (error) {
                // Note: This error isn't pushed to the errors array, because it's not an
                // error in the manifest itself.
                throw new Error(`Failed to update "snap.manifest.json": ${(0, snaps_sdk_1.getErrorMessage)(error)}`);
            }
        }
    }
    return manifestResults;
}
exports.checkManifest = checkManifest;
/**
 * Run the algorithm for automatically fixing errors in manifest.
 *
 * The algorithm updates the manifest by fixing all fixable problems,
 * and then run validation again to check if the new manifest is now correct.
 * If not correct, the algorithm will use the manifest from previous iteration
 * and try again `MAX_ATTEMPTS` times to update it before bailing and
 * resulting in failure.
 *
 * @param results - Results of the initial run of validation.
 * @param rules - Optional list of rules to run the fixes with.
 * @returns The updated manifest and whether it was updated.
 */
async function runFixes(results, rules) {
    let shouldRunFixes = true;
    const MAX_ATTEMPTS = 10;
    (0, utils_1.assert)(results.files);
    let fixResults = results;
    (0, utils_1.assert)(fixResults.files);
    fixResults.files.manifest = fixResults.files.manifest.clone();
    for (let attempts = 1; shouldRunFixes && attempts <= MAX_ATTEMPTS; attempts++) {
        (0, utils_1.assert)(fixResults.files);
        let manifest = fixResults.files.manifest.result;
        const fixable = fixResults.reports.filter((report) => report.fix);
        for (const report of fixable) {
            (0, utils_1.assert)(report.fix);
            ({ manifest } = await report.fix({ manifest }));
        }
        fixResults.files.manifest.value = `${JSON.stringify(getWritableManifest(manifest), null, 2)}\n`;
        fixResults.files.manifest.result = manifest;
        fixResults = await (0, validator_1.runValidators)(fixResults.files, rules);
        shouldRunFixes = (0, validator_1.hasFixes)(fixResults);
    }
    const initialReports = (0, deep_clone_1.deepClone)(results.reports);
    // Was fixed
    if (!shouldRunFixes) {
        for (const report of initialReports) {
            if (report.fix) {
                report.wasFixed = true;
                delete report.fix;
            }
        }
        return {
            files: fixResults.files,
            updated: true,
            reports: initialReports,
        };
    }
    for (const report of initialReports) {
        delete report.fix;
    }
    return {
        files: results.files,
        updated: false,
        reports: initialReports,
    };
}
exports.runFixes = runFixes;
/**
 * Given an unvalidated Snap manifest, attempts to extract the location of the
 * bundle source file location and read the file.
 *
 * @param basePath - The path to the folder with the manifest files.
 * @param manifest - The unvalidated Snap manifest file contents.
 * @param sourceCode - Override source code for plugins.
 * @returns The contents of the bundle file, if any.
 */
async function getSnapSourceCode(basePath, manifest, sourceCode) {
    if (!(0, utils_1.isPlainObject)(manifest)) {
        return undefined;
    }
    const sourceFilePath = manifest.source?.location
        ?.npm?.filePath;
    if (!sourceFilePath) {
        return undefined;
    }
    if (sourceCode) {
        return new node_1.VirtualFile({
            path: path_1.default.join(basePath, sourceFilePath),
            value: sourceCode,
        });
    }
    try {
        const virtualFile = await (0, node_1.readVirtualFile)(path_1.default.join(basePath, sourceFilePath), 'utf8');
        return virtualFile;
    }
    catch (error) {
        throw new Error(`Failed to read snap bundle file: ${(0, snaps_sdk_1.getErrorMessage)(error)}`);
    }
}
exports.getSnapSourceCode = getSnapSourceCode;
/**
 * Given an unvalidated Snap manifest, attempts to extract the location of the
 * icon and read the file.
 *
 * @param basePath - The path to the folder with the manifest files.
 * @param manifest - The unvalidated Snap manifest file contents.
 * @returns The contents of the icon, if any.
 */
async function getSnapIcon(basePath, manifest) {
    if (!(0, utils_1.isPlainObject)(manifest)) {
        return undefined;
    }
    const iconPath = manifest.source?.location?.npm
        ?.iconPath;
    if (!iconPath) {
        return undefined;
    }
    try {
        const virtualFile = await (0, node_1.readVirtualFile)(path_1.default.join(basePath, iconPath), 'utf8');
        return virtualFile;
    }
    catch (error) {
        throw new Error(`Failed to read snap icon file: ${(0, snaps_sdk_1.getErrorMessage)(error)}`);
    }
}
exports.getSnapIcon = getSnapIcon;
/**
 * Get an array of paths from an unvalidated Snap manifest.
 *
 * @param manifest - The unvalidated Snap manifest file contents.
 * @param selector - A function that returns the paths to the files.
 * @returns The paths to the files, if any.
 */
function getSnapFilePaths(manifest, selector) {
    if (!(0, utils_1.isPlainObject)(manifest)) {
        return undefined;
    }
    const snapManifest = manifest;
    const paths = selector(snapManifest);
    if (!Array.isArray(paths)) {
        return undefined;
    }
    return paths;
}
exports.getSnapFilePaths = getSnapFilePaths;
/**
 * Given an unvalidated Snap manifest, attempts to extract the files with the
 * given paths and read them.
 *
 * @param basePath - The path to the folder with the manifest files.
 * @param paths - The paths to the files.
 * @param encoding - An optional encoding to pass down to readVirtualFile.
 * @returns A list of auxiliary files and their contents, if any.
 */
async function getSnapFiles(basePath, paths, encoding = 'utf8') {
    if (!paths) {
        return undefined;
    }
    try {
        return await Promise.all(paths.map(async (filePath) => (0, node_1.readVirtualFile)(path_1.default.join(basePath, filePath), encoding)));
    }
    catch (error) {
        throw new Error(`Failed to read snap files: ${(0, snaps_sdk_1.getErrorMessage)(error)}`);
    }
}
exports.getSnapFiles = getSnapFiles;
/**
 * Sorts the given manifest in our preferred sort order and removes the
 * `repository` field if it is falsy (it may be `null`).
 *
 * @param manifest - The manifest to sort and modify.
 * @returns The disk-ready manifest.
 */
function getWritableManifest(manifest) {
    const { repository, ...remaining } = manifest;
    const keys = Object.keys(repository ? { ...remaining, repository } : remaining);
    const writableManifest = keys
        .sort((a, b) => MANIFEST_SORT_ORDER[a] - MANIFEST_SORT_ORDER[b])
        .reduce((result, key) => ({
        ...result,
        [key]: manifest[key],
    }), {});
    return writableManifest;
}
exports.getWritableManifest = getWritableManifest;
//# sourceMappingURL=manifest.cjs.map