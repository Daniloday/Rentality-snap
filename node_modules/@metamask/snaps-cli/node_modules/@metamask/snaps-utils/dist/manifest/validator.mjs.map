{"version":3,"file":"validator.mjs","sourceRoot":"","sources":["../../src/manifest/validator.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,OAAO,EAAE,MAAM,EAAE,wBAAwB;AAUzC,OAAO,KAAK,iBAAiB,+BAAqB;AAOlD,MAAM,OAAO;IAAb;QACE,YAAO,GAAsB,EAAE,CAAC;QAEhC,gCAAoC,SAAS,EAAC;IAkBhD,CAAC;IAhBC,MAAM,CAAC,OAAe,EAAE,GAAkB;QACxC,MAAM,CAAC,uBAAA,IAAI,6BAAc,KAAK,SAAS,CAAC,CAAC;QACzC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;YAChB,QAAQ,EAAE,uBAAA,IAAI,6BAAc;YAC5B,OAAO;YACP,GAAG;SACJ,CAAC,CAAC;IACL,CAAC;IAED,mBAAmB,CAAC,QAAyC;QAC3D,uBAAA,IAAI,yBAAiB,QAAQ,CAAC,QAAQ,MAAA,CAAC;IACzC,CAAC;IAED,IAAI,SAAS;QACX,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,QAAQ,KAAK,OAAO,CAAC,CAAC;IACpE,CAAC;CACF;;AAED;;;;;;;;GAQG;AACH,iEAAiE;AACjE,8DAA8D;AAC9D,+BAA+B;AAC/B,MAAM,CAAC,KAAK,UAAU,aAAa,CACjC,KAA2B,EAC3B,QAAyB,MAAM,CAAC,MAAM,CAAC,iBAAiB,CAAC;IAEzD,MAAM,OAAO,GAAG,IAAI,OAAO,EAAE,CAAC;IAE9B,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;QACzB,OAAO,CAAC,mBAAmB,CAAC;YAC1B,QAAQ,EAAE,IAAI,CAAC,QAAQ;SACxB,CAAC,CAAC;QACH,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IAC9C,CAAC;IACD,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC;QACtB,OAAO;YACL,OAAO,EAAE,OAAO,CAAC,OAAO;SACzB,CAAC;IACJ,CAAC;IAED,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;QACzB,OAAO,CAAC,mBAAmB,CAAC;YAC1B,QAAQ,EAAE,IAAI,CAAC,QAAQ;SACxB,CAAC,CAAC;QACH,MAAM,IAAI,CAAC,aAAa,EAAE,CAAC,KAAkB,EAAE,OAAO,CAAC,CAAC;IAC1D,CAAC;IACD,OAAO;QACL,KAAK,EAAE,KAAkB;QACzB,OAAO,EAAE,OAAO,CAAC,OAAO;KACzB,CAAC;AACJ,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,QAAQ,CAAC,OAAyB;IAChD,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AACtD,CAAC","sourcesContent":["import { assert } from '@metamask/utils';\n\nimport type { SnapFiles, UnvalidatedSnapFiles } from '../types';\nimport type {\n  ValidatorContext,\n  ValidatorFix,\n  ValidatorMeta,\n  ValidatorReport,\n  ValidatorSeverity,\n} from './validator-types';\nimport * as defaultValidators from './validators';\n\nexport type ValidatorResults = {\n  files?: SnapFiles;\n  reports: ValidatorReport[];\n};\n\nclass Context implements ValidatorContext {\n  reports: ValidatorReport[] = [];\n\n  #nextSeverity?: ValidatorSeverity = undefined;\n\n  report(message: string, fix?: ValidatorFix): void {\n    assert(this.#nextSeverity !== undefined);\n    this.reports.push({\n      severity: this.#nextSeverity,\n      message,\n      fix,\n    });\n  }\n\n  prepareForValidator(settings: { severity: ValidatorSeverity }) {\n    this.#nextSeverity = settings.severity;\n  }\n\n  get hasErrors() {\n    return this.reports.some((report) => report.severity === 'error');\n  }\n}\n\n/**\n * Verify that snap files are completely valid.\n * First it runs validators on unparsed files to check structure.\n * Secondly it runs validators on parsed files to check semantics.\n *\n * @param files - All files required to run a snap.\n * @param rules - Validators to run.\n * @returns The validation results.\n */\n// TODO(ritave): snap.manifest.json and package.json should check\n//               json parsing as well instead of assuming it's\n//               already parsed\nexport async function runValidators(\n  files: UnvalidatedSnapFiles,\n  rules: ValidatorMeta[] = Object.values(defaultValidators),\n): Promise<ValidatorResults> {\n  const context = new Context();\n\n  for (const rule of rules) {\n    context.prepareForValidator({\n      severity: rule.severity,\n    });\n    await rule.structureCheck?.(files, context);\n  }\n  if (context.hasErrors) {\n    return {\n      reports: context.reports,\n    };\n  }\n\n  for (const rule of rules) {\n    context.prepareForValidator({\n      severity: rule.severity,\n    });\n    await rule.semanticCheck?.(files as SnapFiles, context);\n  }\n  return {\n    files: files as SnapFiles,\n    reports: context.reports,\n  };\n}\n\n/**\n * Get whether any reports has pending fixes.\n *\n * @param results - Results of the validation run.\n * @returns Whether there are fixes pending.\n */\nexport function hasFixes(results: ValidatorResults): boolean {\n  return results.reports.some((report) => report.fix);\n}\n"]}