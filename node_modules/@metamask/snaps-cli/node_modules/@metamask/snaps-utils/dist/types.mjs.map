{"version":3,"file":"types.mjs","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,QAAQ,EACR,EAAE,EACF,QAAQ,EACR,OAAO,EACP,MAAM,EACN,IAAI,EACJ,MAAM,EACN,IAAI,EACJ,KAAK,EACL,MAAM,IAAI,iBAAiB,EAC5B,8BAA8B;AAG/B,OAAO,EAAE,aAAa,EAAE,wBAAwB;AAQhD,MAAM,CAAN,IAAY,gBAGX;AAHD,WAAY,gBAAgB;IAC1B,gDAA4B,CAAA;IAC5B,mDAA+B,CAAA;AACjC,CAAC,EAHW,gBAAgB,KAAhB,gBAAgB,QAG3B;AAED,MAAM,CAAC,MAAM,UAAU,GAAG,IAAI,CAC5B,OAAO,CACL,MAAM,EAAE,EACR,6DAA6D,CAC9D,EACD,CAAC,EACD,GAAG,CACJ,CAAC;AAEF,2EAA2E;AAC3E,sBAAsB;AACtB,MAAM,CAAC,MAAM,wBAAwB,GAAG,IAAI,CAAC;IAC3C,OAAO,EAAE,aAAa;IACtB,IAAI,EAAE,UAAU;IAChB,IAAI,EAAE,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;IAC3C,UAAU,EAAE,QAAQ,CAClB,IAAI,CAAC;QACH,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,QAAQ,CAAC;QACjC,GAAG,EAAE,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,QAAQ,CAAC;KACjC,CAAC,CACH;CACF,CAAC,CAAC;AAsCH;;GAEG;AACH,yDAAyD;AACzD,MAAM,CAAN,IAAY,cAGX;AAHD,WAAY,cAAc;IACxB,8BAAY,CAAA;IACZ,kCAAgB,CAAA;AAClB,CAAC,EAHW,cAAc,KAAd,cAAc,QAGzB;AACD,wDAAwD;AAExD,yDAAyD;AACzD,MAAM,CAAN,IAAY,iBAGX;AAHD,WAAY,iBAAiB;IAC3B,yCAAoB,CAAA;IACpB,wCAAmB,CAAA;AACrB,CAAC,EAHW,iBAAiB,KAAjB,iBAAiB,QAG5B;AAqBD,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC,OAAwB,EAAE,EAAE,EAAE,CAChD,MAAM,CAAC,KAAK,CAAC,CAAC,MAAM,EAAE,EAAE,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,EAAE;IACxD,IAAI,CAAC;QACH,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC;QAE3B,MAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;QAC7B,iBAAiB,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;QAClC,OAAO,IAAI,CAAC;IACd,CAAC;IAAC,MAAM,CAAC;QACP,OAAO,sBAAsB,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC;IACpD,CAAC;AACH,CAAC,CAAC,CAAC;AAEL;;;;;;GAMG;AACH,MAAM,UAAU,UAAU,CACxB,GAAY,EACZ,OAAwB,EAAE;IAE1B,OAAO,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;AAC5B,CAAC;AAED,+CAA+C;AAC/C,MAAM,CAAC,MAAM,0BAA0B,GAAG,aAAa,CAAC","sourcesContent":["import {\n  instance,\n  is,\n  optional,\n  pattern,\n  refine,\n  size,\n  string,\n  type,\n  union,\n  assert as assertSuperstruct,\n} from '@metamask/superstruct';\nimport type { Infer, Struct } from '@metamask/superstruct';\nimport type { Json } from '@metamask/utils';\nimport { VersionStruct } from '@metamask/utils';\n\nimport type { SnapCaveatType } from './caveats';\nimport type { SnapFunctionExports, SnapRpcHookArgs } from './handlers';\nimport type { LocalizationFile } from './localization';\nimport type { SnapManifest } from './manifest';\nimport type { VirtualFile } from './virtual-file';\n\nexport enum NpmSnapFileNames {\n  PackageJson = 'package.json',\n  Manifest = 'snap.manifest.json',\n}\n\nexport const NameStruct = size(\n  pattern(\n    string(),\n    /^(?:@[a-z0-9-*~][a-z0-9-*._~]*\\/)?[a-z0-9-~][a-z0-9-._~]*$/u,\n  ),\n  1,\n  214,\n);\n\n// Note we use `type` instead of `object` here, because the latter does not\n// allow unknown keys.\nexport const NpmSnapPackageJsonStruct = type({\n  version: VersionStruct,\n  name: NameStruct,\n  main: optional(size(string(), 1, Infinity)),\n  repository: optional(\n    type({\n      type: size(string(), 1, Infinity),\n      url: size(string(), 1, Infinity),\n    }),\n  ),\n});\n\nexport type NpmSnapPackageJson = Infer<typeof NpmSnapPackageJsonStruct> &\n  Record<string, any>;\n\n/**\n * An object for storing parsed but unvalidated Snap file contents.\n */\nexport type UnvalidatedSnapFiles = {\n  manifest?: VirtualFile<Json>;\n  packageJson?: VirtualFile<Json>;\n  sourceCode?: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile[];\n};\n\n/**\n * An object for storing the contents of Snap files that have passed JSON\n * Schema validation, or are non-empty if they are strings.\n */\nexport type SnapFiles = {\n  manifest: VirtualFile<SnapManifest>;\n  packageJson: VirtualFile<NpmSnapPackageJson>;\n  sourceCode: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile<LocalizationFile>[];\n};\n\n/**\n * A subset of snap files extracted from a fetched snap.\n */\nexport type FetchedSnapFiles = Pick<\n  SnapFiles,\n  'manifest' | 'sourceCode' | 'svgIcon' | 'auxiliaryFiles' | 'localizationFiles'\n>;\n\n/**\n * The possible prefixes for snap ids.\n */\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SnapIdPrefixes {\n  npm = 'npm:',\n  local = 'local:',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SNAP_STREAM_NAMES {\n  JSON_RPC = 'jsonRpc',\n  COMMAND = 'command',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n// The snap is the callee\nexport type SnapRpcHook = (options: SnapRpcHookArgs) => Promise<unknown>;\n\ntype ObjectParameters<\n  Type extends Record<string, (...args: any[]) => unknown>,\n> = Parameters<Type[keyof Type]>;\n\nexport type SnapExportsParameters = ObjectParameters<SnapFunctionExports>;\n\ntype UriOptions<Type extends string> = {\n  protocol?: Struct<Type>;\n  hash?: Struct<Type>;\n  port?: Struct<Type>;\n  hostname?: Struct<Type>;\n  pathname?: Struct<Type>;\n  search?: Struct<Type>;\n};\n\nexport const uri = (opts: UriOptions<any> = {}) =>\n  refine(union([string(), instance(URL)]), 'uri', (value) => {\n    try {\n      const url = new URL(value);\n\n      const UrlStruct = type(opts);\n      assertSuperstruct(url, UrlStruct);\n      return true;\n    } catch {\n      return `Expected URL, got \"${value.toString()}\".`;\n    }\n  });\n\n/**\n * Returns whether a given value is a valid URL.\n *\n * @param url - The value to check.\n * @param opts - Optional constraints for url checking.\n * @returns Whether `url` is valid URL or not.\n */\nexport function isValidUrl(\n  url: unknown,\n  opts: UriOptions<any> = {},\n): url is string | URL {\n  return is(url, uri(opts));\n}\n\n// redefining here to avoid circular dependency\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\nexport type SnapsPermissionRequest = {\n  [WALLET_SNAP_PERMISSION_KEY]: {\n    caveats: [\n      {\n        type: SnapCaveatType.SnapIds;\n        value: Record<string, Json>;\n      },\n    ];\n  };\n};\n"]}