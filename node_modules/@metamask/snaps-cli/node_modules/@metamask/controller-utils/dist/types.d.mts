/**
 * The names of built-in Infura networks
 */
export declare const InfuraNetworkType: {
    readonly mainnet: "mainnet";
    readonly goerli: "goerli";
    readonly sepolia: "sepolia";
    readonly 'linea-goerli': "linea-goerli";
    readonly 'linea-sepolia': "linea-sepolia";
    readonly 'linea-mainnet': "linea-mainnet";
};
export type InfuraNetworkType = (typeof InfuraNetworkType)[keyof typeof InfuraNetworkType];
/**
 * The "network type"; either the name of a built-in network, or "rpc" for custom networks.
 */
export declare const NetworkType: {
    readonly rpc: "rpc";
    readonly mainnet: "mainnet";
    readonly goerli: "goerli";
    readonly sepolia: "sepolia";
    readonly 'linea-goerli': "linea-goerli";
    readonly 'linea-sepolia': "linea-sepolia";
    readonly 'linea-mainnet': "linea-mainnet";
};
export type NetworkType = (typeof NetworkType)[keyof typeof NetworkType];
/**
 * A helper to determine whether a given input is NetworkType.
 *
 * @param val - the value to check whether it is NetworkType or not.
 * @returns boolean indicating whether or not the argument is NetworkType.
 */
export declare function isNetworkType(val: string): val is NetworkType;
/**
 * A type guard to determine whether the input is an InfuraNetworkType.
 *
 * @param value - The value to check.
 * @returns True if the given value is within the InfuraNetworkType enum,
 * false otherwise.
 */
export declare function isInfuraNetworkType(value: unknown): value is InfuraNetworkType;
/**
 * Names of networks built into the wallet.
 *
 * This includes both Infura and non-Infura networks.
 */
export declare enum BuiltInNetworkName {
    Mainnet = "mainnet",
    Goerli = "goerli",
    Sepolia = "sepolia",
    LineaGoerli = "linea-goerli",
    LineaSepolia = "linea-sepolia",
    LineaMainnet = "linea-mainnet",
    Aurora = "aurora"
}
/**
 * Decimal string chain IDs of built-in networks, by name.
 *
 * `toHex` not invoked to avoid cyclic dependency
 */
export declare const ChainId: {
    readonly mainnet: "0x1";
    readonly goerli: "0x5";
    readonly sepolia: "0xaa36a7";
    readonly aurora: "0x4e454152";
    readonly "linea-goerli": "0xe704";
    readonly "linea-sepolia": "0xe705";
    readonly "linea-mainnet": "0xe708";
};
export type ChainId = (typeof ChainId)[keyof typeof ChainId];
export declare enum NetworksTicker {
    mainnet = "ETH",
    goerli = "GoerliETH",
    sepolia = "SepoliaETH",
    'linea-goerli' = "LineaETH",
    'linea-sepolia' = "LineaETH",
    'linea-mainnet' = "ETH",
    rpc = ""
}
export declare const BlockExplorerUrl: {
    readonly mainnet: "https://etherscan.io";
    readonly goerli: "https://goerli.etherscan.io";
    readonly sepolia: "https://sepolia.etherscan.io";
    readonly "linea-goerli": "https://goerli.lineascan.build";
    readonly "linea-sepolia": "https://sepolia.lineascan.build";
    readonly "linea-mainnet": "https://lineascan.build";
};
export type BlockExplorerUrl = (typeof BlockExplorerUrl)[keyof typeof BlockExplorerUrl];
export declare const NetworkNickname: {
    readonly mainnet: "Ethereum Mainnet";
    readonly goerli: "Goerli";
    readonly sepolia: "Sepolia";
    readonly "linea-goerli": "Linea Goerli";
    readonly "linea-sepolia": "Linea Sepolia";
    readonly "linea-mainnet": "Linea";
};
export type NetworkNickname = (typeof NetworkNickname)[keyof typeof NetworkNickname];
/**
 * Makes a selection of keys in a Record optional.
 *
 * @template Type - The Record that you want to operate on.
 * @template Key - The union of keys you want to make optional.
 */
export type Partialize<Type, Key extends keyof Type> = Omit<Type, Key> & Partial<Pick<Type, Key>>;
/** A context in which to execute a trace, in order to generate nested timings. */
export type TraceContext = unknown;
/** Request to trace an operation. */
export type TraceRequest = {
    /** Additional data to include in the trace. */
    data?: Record<string, number | string | boolean>;
    /** Name of the operation. */
    name: string;
    /**
     * Unique identifier for the trace.
     * Required if starting a trace and not providing a callback.
     */
    id?: string;
    /** Trace context in which to execute the operation. */
    parentContext?: TraceContext;
    /** Additional tags to include in the trace to filter results. */
    tags?: Record<string, number | string | boolean>;
};
/** Callback that traces the performance of an operation. */
export type TraceCallback = <ReturnType>(
/** Request to trace the performance of an operation. */
request: TraceRequest, 
/**
 * Callback to trace.
 * Thrown errors will not be caught, but the trace will still be recorded.
 * @param context - The context in which the operation is running.
 */
fn?: (context?: TraceContext) => ReturnType) => Promise<ReturnType>;
//# sourceMappingURL=types.d.mts.map