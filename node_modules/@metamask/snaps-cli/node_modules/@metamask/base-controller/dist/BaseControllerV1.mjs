/**
 * Determines if the given controller is an instance of `BaseControllerV1`
 *
 * @param controller - Controller instance to check
 * @returns True if the controller is an instance of `BaseControllerV1`
 */
export function isBaseControllerV1(controller) {
    return ('name' in controller &&
        typeof controller.name === 'string' &&
        'config' in controller &&
        typeof controller.config === 'object' &&
        'defaultConfig' in controller &&
        typeof controller.defaultConfig === 'object' &&
        'state' in controller &&
        typeof controller.state === 'object' &&
        'defaultState' in controller &&
        typeof controller.defaultState === 'object' &&
        'disabled' in controller &&
        typeof controller.disabled === 'boolean' &&
        'subscribe' in controller &&
        typeof controller.subscribe === 'function');
}
/**
 * @deprecated This class has been renamed to BaseControllerV1 and is no longer recommended for use for controllers. Please use BaseController (formerly BaseControllerV2) instead.
 *
 * Controller class that provides configuration, state management, and subscriptions.
 *
 * The core purpose of every controller is to maintain an internal data object
 * called "state". Each controller is responsible for its own state, and all global wallet state
 * is tracked in a controller as state.
 */
// TODO: Either fix this lint violation or explain why it's necessary to ignore.
// eslint-disable-next-line @typescript-eslint/naming-convention
export class BaseControllerV1 {
    /**
     * Creates a BaseControllerV1 instance. Both initial state and initial
     * configuration options are merged with defaults upon initialization.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config = {}, state = {}) {
        /**
         * Default options used to configure this controller
         */
        this.defaultConfig = {};
        /**
         * Default state set on this controller
         */
        this.defaultState = {};
        /**
         * Determines if listeners are notified of state changes
         */
        this.disabled = false;
        /**
         * Name of this controller used during composition
         */
        this.name = 'BaseController';
        this.internalConfig = this.defaultConfig;
        this.internalState = this.defaultState;
        this.internalListeners = [];
        this.initialState = state;
        this.initialConfig = config;
    }
    /**
     * Enables the controller. This sets each config option as a member
     * variable on this instance and triggers any defined setters. This
     * also sets initial state and triggers any listeners.
     *
     * @returns This controller instance.
     */
    initialize() {
        this.internalState = this.defaultState;
        this.internalConfig = this.defaultConfig;
        this.configure(this.initialConfig);
        this.update(this.initialState);
        return this;
    }
    /**
     * Retrieves current controller configuration options.
     *
     * @returns The current configuration.
     */
    get config() {
        return this.internalConfig;
    }
    /**
     * Retrieves current controller state.
     *
     * @returns The current state.
     */
    get state() {
        return this.internalState;
    }
    /**
     * Updates controller configuration.
     *
     * @param config - New configuration options.
     * @param overwrite - Overwrite config instead of merging.
     * @param fullUpdate - Boolean that defines if the update is partial or not.
     */
    configure(config, overwrite = false, fullUpdate = true) {
        if (fullUpdate) {
            this.internalConfig = overwrite
                ? config
                : Object.assign(this.internalConfig, config);
            for (const key of Object.keys(this.internalConfig)) {
                const value = this.internalConfig[key];
                if (value !== undefined) {
                    this[key] = value;
                }
            }
        }
        else {
            for (const key of Object.keys(config)) {
                /* istanbul ignore else */
                if (this.internalConfig[key] !== undefined) {
                    const value = config[key];
                    this.internalConfig[key] = value;
                    this[key] = value;
                }
            }
        }
    }
    /**
     * Notifies all subscribed listeners of current state.
     */
    notify() {
        if (this.disabled) {
            return;
        }
        this.internalListeners.forEach((listener) => {
            listener(this.internalState);
        });
    }
    /**
     * Adds new listener to be notified of state changes.
     *
     * @param listener - The callback triggered when state changes.
     */
    subscribe(listener) {
        this.internalListeners.push(listener);
    }
    /**
     * Removes existing listener from receiving state changes.
     *
     * @param listener - The callback to remove.
     * @returns `true` if a listener is found and unsubscribed.
     */
    unsubscribe(listener) {
        const index = this.internalListeners.findIndex((cb) => listener === cb);
        index > -1 && this.internalListeners.splice(index, 1);
        return index > -1;
    }
    /**
     * Updates controller state.
     *
     * @param state - The new state.
     * @param overwrite - Overwrite state instead of merging.
     */
    update(state, overwrite = false) {
        this.internalState = overwrite
            ? Object.assign({}, state)
            : Object.assign({}, this.internalState, state);
        this.notify();
    }
}
export default BaseControllerV1;
//# sourceMappingURL=BaseControllerV1.mjs.map