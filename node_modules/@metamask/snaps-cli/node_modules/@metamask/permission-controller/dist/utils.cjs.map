{"version":3,"file":"utils.cjs","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":";;;AAsBA,IAAY,WAIX;AAJD,WAAY,WAAW;IACrB,+DAAgD,CAAA;IAChD,uDAAwC,CAAA;IACxC,6DAA8C,CAAA;AAChD,CAAC,EAJW,WAAW,2BAAX,WAAW,QAItB;AAsDD;;;;;;;;;;;GAWG;AACH,SAAgB,6BAA6B,CAC3C,cAAyD,EACzD,eAA8C;IAE9C,MAAM,WAAW,GAAG,cAAc,EAAE,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC;IAC3D,MAAM,YAAY,GAAG,eAAe,CAAC,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC;IAC5D,MAAM,iBAAiB,GAAuB,EAAE,CAAC;IACjD,MAAM,WAAW,GAA2C,EAAE,CAAC;IAE/D,WAAW,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,EAAE;QACjC,MAAM,gBAAgB,GAAG,YAAY,CAAC,SAAS,CAC7C,CAAC,WAAW,EAAE,EAAE,CAAC,WAAW,CAAC,IAAI,KAAK,UAAU,CAAC,IAAI,CACtD,CAAC;QAEF,IAAI,gBAAgB,KAAK,CAAC,CAAC,EAAE;YAC3B,iBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SACpC;aAAM;YACL,WAAW,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,YAAY,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;YAC/D,YAAY,CAAC,MAAM,CAAC,gBAAgB,EAAE,CAAC,CAAC,CAAC;SAC1C;IACH,CAAC,CAAC,CAAC;IAEH,OAAO;QACL,WAAW;QACX,iBAAiB;QACjB,kBAAkB,EAAE,CAAC,GAAG,YAAY,CAAC;KACtC,CAAC;AACJ,CAAC;AA3BD,sEA2BC","sourcesContent":["import type {\n  JsonRpcEngineEndCallback,\n  JsonRpcEngineNextCallback,\n} from '@metamask/json-rpc-engine';\nimport type {\n  Json,\n  JsonRpcParams,\n  JsonRpcRequest,\n  PendingJsonRpcResponse,\n} from '@metamask/utils';\n\nimport type {\n  CaveatConstraint,\n  CaveatSpecificationConstraint,\n  CaveatSpecificationMap,\n} from './Caveat';\nimport type {\n  PermissionConstraint,\n  PermissionSpecificationConstraint,\n  PermissionSpecificationMap,\n} from './Permission';\n\nexport enum MethodNames {\n  RequestPermissions = 'wallet_requestPermissions',\n  GetPermissions = 'wallet_getPermissions',\n  RevokePermissions = 'wallet_revokePermissions',\n}\n\n/**\n * Utility type for extracting a union of all individual caveat or permission\n * specification types from a {@link CaveatSpecificationMap} or\n * {@link PermissionSpecificationMap}.\n *\n * @template SpecificationsMap - The caveat or permission specifications map\n * whose specification type union to extract.\n */\nexport type ExtractSpecifications<\n  SpecificationsMap extends\n    | CaveatSpecificationMap<CaveatSpecificationConstraint>\n    | PermissionSpecificationMap<PermissionSpecificationConstraint>,\n> = SpecificationsMap[keyof SpecificationsMap];\n\n/**\n * A middleware function for handling a permitted method.\n */\nexport type HandlerMiddlewareFunction<\n  Hooks,\n  Params extends JsonRpcParams,\n  Result extends Json,\n> = (\n  req: JsonRpcRequest<Params>,\n  res: PendingJsonRpcResponse<Result>,\n  next: JsonRpcEngineNextCallback,\n  end: JsonRpcEngineEndCallback,\n  hooks: Hooks,\n) => void | Promise<void>;\n\n/**\n * We use a mapped object type in order to create a type that requires the\n * presence of the names of all hooks for the given handler.\n * This can then be used to select only the necessary hooks whenever a method\n * is called for purposes of POLA.\n */\nexport type HookNames<HookMap> = {\n  [Property in keyof HookMap]: true;\n};\n\n/**\n * A handler for a permitted method.\n */\nexport type PermittedHandlerExport<\n  Hooks,\n  Params extends JsonRpcParams,\n  Result extends Json,\n> = {\n  implementation: HandlerMiddlewareFunction<Hooks, Params, Result>;\n  hookNames: HookNames<Hooks>;\n  methodNames: string[];\n};\n\n/**\n * Given two permission objects, computes 3 sets:\n * - The set of caveat pairs that are common to both permissions.\n * - The set of caveats that are unique to the existing permission.\n * - The set of caveats that are unique to the requested permission.\n *\n * Assumes that the caveat arrays of both permissions are valid.\n *\n * @param leftPermission - The left-hand permission.\n * @param rightPermission - The right-hand permission.\n * @returns The sets of caveat pairs and unique caveats.\n */\nexport function collectUniqueAndPairedCaveats(\n  leftPermission: Partial<PermissionConstraint> | undefined,\n  rightPermission: Partial<PermissionConstraint>,\n) {\n  const leftCaveats = leftPermission?.caveats?.slice() ?? [];\n  const rightCaveats = rightPermission.caveats?.slice() ?? [];\n  const leftUniqueCaveats: CaveatConstraint[] = [];\n  const caveatPairs: [CaveatConstraint, CaveatConstraint][] = [];\n\n  leftCaveats.forEach((leftCaveat) => {\n    const rightCaveatIndex = rightCaveats.findIndex(\n      (rightCaveat) => rightCaveat.type === leftCaveat.type,\n    );\n\n    if (rightCaveatIndex === -1) {\n      leftUniqueCaveats.push(leftCaveat);\n    } else {\n      caveatPairs.push([leftCaveat, rightCaveats[rightCaveatIndex]]);\n      rightCaveats.splice(rightCaveatIndex, 1);\n    }\n  });\n\n  return {\n    caveatPairs,\n    leftUniqueCaveats,\n    rightUniqueCaveats: [...rightCaveats],\n  };\n}\n"]}