"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectUniqueAndPairedCaveats = exports.MethodNames = void 0;
var MethodNames;
(function (MethodNames) {
    MethodNames["RequestPermissions"] = "wallet_requestPermissions";
    MethodNames["GetPermissions"] = "wallet_getPermissions";
    MethodNames["RevokePermissions"] = "wallet_revokePermissions";
})(MethodNames || (exports.MethodNames = MethodNames = {}));
/**
 * Given two permission objects, computes 3 sets:
 * - The set of caveat pairs that are common to both permissions.
 * - The set of caveats that are unique to the existing permission.
 * - The set of caveats that are unique to the requested permission.
 *
 * Assumes that the caveat arrays of both permissions are valid.
 *
 * @param leftPermission - The left-hand permission.
 * @param rightPermission - The right-hand permission.
 * @returns The sets of caveat pairs and unique caveats.
 */
function collectUniqueAndPairedCaveats(leftPermission, rightPermission) {
    const leftCaveats = leftPermission?.caveats?.slice() ?? [];
    const rightCaveats = rightPermission.caveats?.slice() ?? [];
    const leftUniqueCaveats = [];
    const caveatPairs = [];
    leftCaveats.forEach((leftCaveat) => {
        const rightCaveatIndex = rightCaveats.findIndex((rightCaveat) => rightCaveat.type === leftCaveat.type);
        if (rightCaveatIndex === -1) {
            leftUniqueCaveats.push(leftCaveat);
        }
        else {
            caveatPairs.push([leftCaveat, rightCaveats[rightCaveatIndex]]);
            rightCaveats.splice(rightCaveatIndex, 1);
        }
    });
    return {
        caveatPairs,
        leftUniqueCaveats,
        rightUniqueCaveats: [...rightCaveats],
    };
}
exports.collectUniqueAndPairedCaveats = collectUniqueAndPairedCaveats;
//# sourceMappingURL=utils.cjs.map